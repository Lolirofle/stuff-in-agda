module Data.List.Proofs where

import Lvl
open import Functional as Fn using (_‚àò_ ; const)
open import Data.Option using (Option ; Some ; None)
import      Data.Option.Functions as Option
open import Data.List
open import Data.List.Equiv
open import Data.List.Functions
open import Logic
open import Numeral.Natural
open import Numeral.Natural.Oper
open import Numeral.Natural.Oper.Proofs
open import Relator.Equals renaming (_‚â°_ to _‚â°‚Çë_ ; _‚â¢_ to _‚â¢‚Çë_)
open import Structure.Function
open import Structure.Function.Domain
open import Structure.Function.Multi
import      Structure.Function.Names as Names
import      Structure.Operator.Names as Names
open import Structure.Operator.Proofs.Util
open import Structure.Operator.Properties
open import Structure.Operator
open import Structure.Relator.Properties
open import Structure.Setoid
open import Syntax.Transitivity
open import Type

private variable ‚Ñì ‚Ñì‚Çë ‚Ñì‚Çë‚Çó ‚Ñì‚Çë‚Çí ‚Ñì‚Çë‚ÇÅ ‚Ñì‚Çë‚ÇÇ ‚Ñì‚Çë‚ÇÉ ‚Ñì‚Çë‚Çó‚ÇÅ ‚Ñì‚Çë‚Çó‚ÇÇ ‚Ñì‚Çë‚Çó‚ÇÉ : Lvl.Level
private variable T A B C D : Type{‚Ñì}
private variable n : ‚Ñï

module _ ‚¶É equiv : Equiv{‚Ñì‚Çë}(T) ‚¶Ñ ‚¶É equiv-List : Equiv{‚Ñì‚Çë‚Çó}(List(T)) ‚¶Ñ ‚¶É extensionality : Extensionality(equiv-List) ‚¶Ñ where
  private variable l l‚ÇÅ l‚ÇÇ : List(T)
  private variable a b x : T
  private variable P : List(T) ‚Üí Stmt{‚Ñì}

  open Equiv(equiv-List) using () renaming (_‚â°_ to _‚â°‚Çó_)

  instance
    tail-function : Function(tail)
    Function.congruence tail-function {‚àÖ}      {‚àÖ}      p = p
    Function.congruence tail-function {‚àÖ}      {x ‚ä∞ y}  p with () ‚Üê [‚àÖ][‚ä∞]-unequal p
    Function.congruence tail-function {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) p)
    Function.congruence tail-function {x ‚ä∞ xl} {y ‚ä∞ yl} p = [‚ä∞]-generalized-cancellation‚Çó p

  instance
    first-function : ‚¶É equiv-Option : Equiv{‚Ñì‚Çë‚Çí}(Option(T)) ‚¶Ñ ‚¶É Some-function : Function(Some) ‚¶Ñ ‚Üí Function(first)
    Function.congruence first-function {‚àÖ}      {‚àÖ}      p = reflexivity(_‚â°_)
    Function.congruence first-function {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ][‚ä∞]-unequal p
    Function.congruence first-function {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) p)
    Function.congruence first-function {x ‚ä∞ xl} {y ‚ä∞ yl} p = congruence‚ÇÅ(Some) ([‚ä∞]-generalized-cancellation·µ£ p)

  instance
    [‚ä∞]-cancellation‚Çó : Cancellation‚Çó(_‚ä∞_)
    Cancellation‚Çó.proof([‚ä∞]-cancellation‚Çó) = [‚ä∞]-generalized-cancellation‚Çó

  instance
    [‚ä∞]-cancellation·µ£ : Cancellation·µ£(_‚ä∞_)
    Cancellation·µ£.proof([‚ä∞]-cancellation·µ£) = [‚ä∞]-generalized-cancellation·µ£

  [‚ä∞]-unequal : (x ‚ä∞ l ‚â¢ l)
  [‚ä∞]-unequal {l = ‚àÖ} = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)
  [‚ä∞]-unequal {l = x ‚ä∞ l} = [‚ä∞]-unequal {l = l} ‚àò [‚ä∞]-generalized-cancellation‚Çó

  postpend-of-prepend : (postpend a (b ‚ä∞ l) ‚â° b ‚ä∞ postpend a l)
  postpend-of-prepend = reflexivity(_‚â°_)

  instance
    postpend-function : BinaryOperator(postpend)
    postpend-function = intro p where
      p : Names.Congruence‚ÇÇ(postpend)
      p {x‚ÇÇ = ‚àÖ}        {y‚ÇÇ = ‚àÖ}        px pl = congruence‚ÇÇ(_‚ä∞_) px pl
      p {x‚ÇÇ = ‚àÖ}        {y‚ÇÇ = y‚ÇÇ ‚ä∞ yl‚ÇÇ} px pl with () ‚Üê [‚àÖ][‚ä∞]-unequal pl
      p {x‚ÇÇ = x‚ÇÇ ‚ä∞ xl‚ÇÇ} {y‚ÇÇ = ‚àÖ}        px pl with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) pl)
      p {x‚ÇÇ = x‚ÇÇ ‚ä∞ xl‚ÇÇ} {y‚ÇÇ = y‚ÇÇ ‚ä∞ yl‚ÇÇ} px pl = congruence‚ÇÇ(_‚ä∞_) ([‚ä∞]-generalized-cancellation·µ£ pl) (p{x‚ÇÇ = xl‚ÇÇ} {y‚ÇÇ = yl‚ÇÇ} px ([‚ä∞]-generalized-cancellation‚Çó pl))

  instance
    reverse-function : Function(reverse)
    reverse-function = intro p where
      p : Names.Congruence‚ÇÅ(reverse)
      p {‚àÖ}      {‚àÖ}      pl = reflexivity(_‚â°_)
      p {‚àÖ}      {y ‚ä∞ yl} pl with () ‚Üê [‚àÖ][‚ä∞]-unequal pl
      p {x ‚ä∞ xl} {‚àÖ}      pl with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) pl)
      p {x ‚ä∞ xl} {y ‚ä∞ yl} pl = congruence‚ÇÇ(postpend) ([‚ä∞]-generalized-cancellation·µ£ pl) (p([‚ä∞]-generalized-cancellation‚Çó pl))

  instance
    [++]-identity‚Çó : Identity‚Çó(_++_) ‚àÖ
    Identity‚Çó.proof([++]-identity‚Çó) = reflexivity(_‚â°_)

  instance
    [++]-identity·µ£ : Identity·µ£(_++_) ‚àÖ
    Identity·µ£.proof([++]-identity·µ£) {x = l} = elim (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ·µ£(_‚ä∞_)(x) {l ++ ‚àÖ}{l}) l

  instance
    [++]-associativity : Associativity(_++_)
    Associativity.proof([++]-associativity) {l‚ÇÅ}{l‚ÇÇ}{l‚ÇÉ} = elim (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ·µ£(_‚ä∞_)(x) {(l ++ l‚ÇÇ) ++ l‚ÇÉ}{l ++ (l‚ÇÇ ++ l‚ÇÉ)}) l‚ÇÅ

  reverse-postpend : (reverse(postpend a l) ‚â° a ‚ä∞ reverse l)
  reverse-postpend {a = a}{l = l} = elim (reflexivity(_‚â°‚Çó_)) (\x l p ‚Üí congruence‚ÇÇ·µ£(postpend) ‚¶É postpend-function ‚¶Ñ (x) {reverse(postpend a l)}{a ‚ä∞ reverse l} p) l

  prepend-[++] : (a ‚ä∞ l ‚â° singleton{T = T}(a) ++ l)
  prepend-[++] = reflexivity(_‚â°_)

  postpend-[++] : (postpend{T = T} a l ‚â° l ++ singleton(a))
  postpend-[++] {a = a}{l = l} = elim (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ·µ£(_‚ä∞_)(x) {postpend a l}{l ++ (singleton a)}) l

  postpend-of-[++] : (postpend{T = T} a (l‚ÇÅ ++ l‚ÇÇ) ‚â° l‚ÇÅ ++ postpend a l‚ÇÇ)
  postpend-of-[++] {a = a} {l‚ÇÅ}{l‚ÇÇ} = elim (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ·µ£(_‚ä∞_)(x) {postpend a (l ++ l‚ÇÇ)}{l ++ (postpend a l‚ÇÇ)}) l‚ÇÅ

  reverse-[++] : (reverse(l‚ÇÅ ++ l‚ÇÇ) ‚â° reverse(l‚ÇÇ) ++ reverse(l‚ÇÅ))
  reverse-[++] {l‚ÇÅ = l‚ÇÅ} {l‚ÇÇ = l‚ÇÇ} = elim
    (congruence‚ÇÅ(reverse) (identity‚Çó(_++_)(‚àÖ) {l‚ÇÇ}) üùñ symmetry(_‚â°_) (identity·µ£(_++_)(‚àÖ) {reverse l‚ÇÇ}))
    (\x l‚ÇÅ p ‚Üí congruence‚ÇÇ·µ£(postpend) ‚¶É postpend-function ‚¶Ñ (x) {reverse (l‚ÇÅ ++ l‚ÇÇ)}{reverse l‚ÇÇ ++ reverse l‚ÇÅ} p üùñ postpend-of-[++] {l‚ÇÅ = reverse l‚ÇÇ} {l‚ÇÇ = reverse l‚ÇÅ})
    l‚ÇÅ

  [‚àÖ]-postpend-unequal : (postpend x l ‚â¢ ‚àÖ)
  [‚àÖ]-postpend-unequal {l = ‚àÖ}     = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)
  [‚àÖ]-postpend-unequal {l = _ ‚ä∞ l} = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)

  postpend-unequal : (postpend x l ‚â¢ l)
  postpend-unequal {l = ‚àÖ}     = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)
  postpend-unequal {l = y ‚ä∞ l} = postpend-unequal {l = l} ‚àò cancellation‚Çó(_‚ä∞_)

  [++]-middle-prepend-postpend : postpend x l‚ÇÅ ++ l‚ÇÇ ‚â° l‚ÇÅ ++ (x ‚ä∞ l‚ÇÇ)
  [++]-middle-prepend-postpend {l‚ÇÅ = ‚àÖ}      {l‚ÇÇ = ‚àÖ} = reflexivity(_‚â°_)
  [++]-middle-prepend-postpend {l‚ÇÅ = ‚àÖ}      {l‚ÇÇ = x ‚ä∞ l‚ÇÇ} = reflexivity(_‚â°_)
  [++]-middle-prepend-postpend {l‚ÇÅ = x ‚ä∞ l‚ÇÅ} {l‚ÇÇ = l‚ÇÇ} = congruence‚ÇÇ·µ£(_‚ä∞_)(x) ([++]-middle-prepend-postpend {l‚ÇÅ = l‚ÇÅ} {l‚ÇÇ = l‚ÇÇ})

  instance
    [++]-cancellation‚Çó : Cancellation‚Çó(_++_)
    Cancellation‚Çó.proof [++]-cancellation‚Çó {x}{y}{z} = proof {x}{y}{z} where
      proof : Names.Cancellation‚Çó (_++_)
      proof {‚àÖ}     p = p
      proof {x ‚ä∞ l} p = proof {l} (cancellation‚Çó(_‚ä∞_) p)

  instance
    [++]-cancellation·µ£ : Cancellation·µ£(_++_)
    Cancellation·µ£.proof([++]-cancellation·µ£) {a}{b} = proof {a}{b} where
      proof : Names.Cancellation·µ£(_++_)
      proof {z}      {‚àÖ}      {‚àÖ}      p = reflexivity(_‚â°_)
      proof {z}      {x ‚ä∞ xl} {y ‚ä∞ yl} p = congruence‚ÇÇ(_‚ä∞_) ([‚ä∞]-generalized-cancellation·µ£ p) (proof {z}{xl}{yl} ([‚ä∞]-generalized-cancellation‚Çó p))
      proof {‚àÖ}      {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ][‚ä∞]-unequal {l = yl} (p üùñ identity·µ£(_++_)(‚àÖ))
      proof {z ‚ä∞ zl} {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ]-postpend-unequal(symmetry(_‚â°_) (proof{zl}{‚àÖ}{postpend z yl} ([‚ä∞]-generalized-cancellation‚Çó p üùñ symmetry(_‚â°_) ([++]-middle-prepend-postpend {x = z}{l‚ÇÅ = yl}{l‚ÇÇ = zl}))))
      proof {‚àÖ}      {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal {l = xl} (symmetry(_‚â°_) p üùñ identity·µ£(_++_)(‚àÖ))
      proof {z ‚ä∞ zl} {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ]-postpend-unequal(proof{zl}{postpend z xl}{‚àÖ} ([++]-middle-prepend-postpend {x = z}{l‚ÇÅ = xl}{l‚ÇÇ = zl} üùñ [‚ä∞]-generalized-cancellation‚Çó p))

  reverse-involution-raw : Names.Involution(reverse{T = T})
  reverse-involution-raw {x = ‚àÖ}     = reflexivity(_‚â°_)
  reverse-involution-raw {x = x ‚ä∞ l} = reverse-postpend {a = x}{l = reverse l} üùñ congruence‚ÇÇ·µ£(_‚ä∞_)(x) (reverse-involution-raw {x = l})

  instance
    reverse-involution : Involution(reverse{T = T})
    Involution.proof reverse-involution = reverse-involution-raw

  initial-of-‚àÖ : (initial(n)(‚àÖ {T = T}) ‚â° ‚àÖ)
  initial-of-‚àÖ {n = ùüé}    = reflexivity(_‚â°_)
  initial-of-‚àÖ {n = ùêí(n)} = reflexivity(_‚â°_)


  module _ where
    open import Relator.Equals.Proofs.Equiv {T = ‚Ñï}
    fold·µ£-constant-[+]·µ£ : ‚àÄ{init step} ‚Üí (fold·µ£ (const(_+ step)) init l ‚â°‚Çë (step ‚ãÖ length(l)) + init)
    fold·µ£-constant-[+]·µ£ {l = ‚àÖ} = reflexivity(_‚â°‚Çë_)
    fold·µ£-constant-[+]·µ£ {l = x ‚ä∞ l} {init}{step} =
      const(_+ step) x (fold·µ£ (const(_+ step)) init l) üùñ[ _‚â°_ ]-[]
      (fold·µ£ (const(_+ step)) init l) + step           üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(_+ step) (fold·µ£-constant-[+]·µ£ {l = l} {init}{step}) ]
      ((step ‚ãÖ length(l)) + init) + step               üùñ[ _‚â°_ ]-[ One.commute·µ£-assoc‚Çó {a = step ‚ãÖ length(l)}{init}{step} ]
      ((step ‚ãÖ length(l)) + step) + init               üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(_+ init) (commutativity(_+_) {step ‚ãÖ length(l)}{step}) ]
      (step + (step ‚ãÖ length(l))) + init               üùñ-end

    fold·µ£-constant-[+]‚Çó : ‚àÄ{init step} ‚Üí (fold·µ£ (const(step +_)) init l ‚â° (length(l) ‚ãÖ step) + init)
    fold·µ£-constant-[+]‚Çó {l = ‚àÖ}                  = reflexivity(_‚â°_)
    fold·µ£-constant-[+]‚Çó {l = x ‚ä∞ l} {init}{step} =
      fold·µ£(const(step +_)) init (x ‚ä∞ l)  üùñ[ _‚â°_ ]-[]
      step + fold·µ£(const(step +_)) init l üùñ[ _‚â°_ ]-[ congruence‚ÇÇ·µ£(_+_)(step) (fold·µ£-constant-[+]‚Çó {l = l} {init}{step}) ]
      step + ((length(l) ‚ãÖ step) + init)  üùñ[ _‚â°_ ]-[ associativity(_+_) {step}{length(l) ‚ãÖ step}{init} ]-sym
      (step + (length(l) ‚ãÖ step)) + init  üùñ[ _‚â°_ ]-[ congruence‚ÇÇ‚Çó(_+_)(init) (commutativity(_+_) {step}{length(l) ‚ãÖ step}) ]
      ((length(l) ‚ãÖ step) + step) + init  üùñ[ _‚â°_ ]-[ congruence‚ÇÇ‚Çó(_+_)(init) ([‚ãÖ]-with-[ùêí]‚Çó {length(l)}{step}) ]-sym
      (ùêí(length(l)) ‚ãÖ step) + init        üùñ[ _‚â°_ ]-[]
      (length(x ‚ä∞ l) ‚ãÖ step) + init       üùñ-end

  instance
    [++^]-identity·µ£ : Identity·µ£(_++^_ {T = T})(ùüè)
    [++^]-identity·µ£ = intro p where
      p : Names.Identity·µ£(_++^_)(ùüè)
      p{‚àÖ}     = reflexivity(_‚â°_)
      p{x ‚ä∞ l} = congruence‚ÇÇ·µ£(_‚ä∞_)(x) (p{l})

open import Structure.Setoid
module _
  ‚¶É equiv-A : Equiv{‚Ñì‚Çë‚ÇÅ}(A) ‚¶Ñ ‚¶É equiv-List‚ÇÅ : Equiv{‚Ñì‚Çë‚Çó‚ÇÅ}(List(A)) ‚¶Ñ ‚¶É extensionality-A : Extensionality(equiv-List‚ÇÅ) ‚¶Ñ
  ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ ‚¶É equiv-List‚ÇÇ : Equiv{‚Ñì‚Çë‚Çó‚ÇÇ}(List(B)) ‚¶Ñ ‚¶É extensionality-B : Extensionality(equiv-List‚ÇÇ) ‚¶Ñ
  where

  private variable l l‚ÇÅ l‚ÇÇ : List(T)
  private variable a b x : T
  private variable P : List(T) ‚Üí Stmt{‚Ñì}

  private variable f g : A ‚Üí B

  map-postpend : (map f(postpend a l) ‚â° postpend (f(a)) (map f(l)))
  map-postpend {f = f} {a = a}{l = l} = elim (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ·µ£(_‚ä∞_)(f(x)) {map f (postpend a l)}{postpend (f(a)) (map f l)}) l

  instance
    map-preserves-[++] : Preserving‚ÇÇ(map f)(_++_)(_++_)
    Preserving.proof (map-preserves-[++] {f = f}) {l‚ÇÅ} {l‚ÇÇ} = elim (reflexivity(_‚â°_)) (\x l‚ÇÅ ‚Üí congruence‚ÇÇ·µ£(_‚ä∞_)(f(x)) {map f(l‚ÇÅ ++ l‚ÇÇ)}{(map f l‚ÇÅ) ++ (map f l‚ÇÇ)}) l‚ÇÅ

  open import Function.Equals using (_‚äú_)
  open import Logic.Propositional
  open import Syntax.Implication
  map-operator-raw : ‚àÄ ‚¶É func-f : Function(f) ‚¶Ñ ‚Üí (f ‚äú g) ‚Üí (l‚ÇÅ ‚â° l‚ÇÇ) ‚Üí (map f(l‚ÇÅ) ‚â° map g(l‚ÇÇ))
  map-operator-raw {f} {g} {‚àÖ}       {‚àÖ}       fg xy = reflexivity(_‚â°_)
  map-operator-raw {f} {g} {‚àÖ}       {x‚ÇÇ ‚ä∞ l‚ÇÇ} fg xy with () ‚Üê [‚àÖ][‚ä∞]-unequal xy
  map-operator-raw {f} {g} {x‚ÇÅ ‚ä∞ l‚ÇÅ} {‚àÖ}       fg xy with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) xy)
  map-operator-raw {f} {g} {x‚ÇÅ ‚ä∞ l‚ÇÅ} {x‚ÇÇ ‚ä∞ l‚ÇÇ} fg xy =
    ‚Ä¢ (
      f(x‚ÇÅ) üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(f) ([‚àß]-elim‚Çó([‚ä∞]-generalized-cancellation xy)) ]
      f(x‚ÇÇ) üùñ[ _‚â°_ ]-[ _‚äú_.proof fg {x‚ÇÇ} ]
      g(x‚ÇÇ) üùñ-end
    )
    ‚Ä¢ (
      map f(l‚ÇÅ) üùñ[ _‚â°_ ]-[ map-operator-raw fg ([‚àß]-elim·µ£([‚ä∞]-generalized-cancellation xy)) ]
      map g(l‚ÇÇ) üùñ-end
    )
    ‚áí‚ÇÇ-[ congruence‚ÇÇ(_‚ä∞_) ]
    (f(x‚ÇÅ) ‚ä∞ map f(l‚ÇÅ) ‚â° g(x‚ÇÇ) ‚ä∞ map g(l‚ÇÇ)) ‚áí-end

  map-injective : ‚¶É inj : Injective(f) ‚¶Ñ ‚Üí Injective(map f)
  map-injective {f = f} = intro proof where
    proof : Names.Injective(map f)
    proof {‚àÖ}      {‚àÖ}      p = reflexivity(_‚â°_)
    proof {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ][‚ä∞]-unequal p
    proof {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) p)
    proof {x ‚ä∞ xl} {y ‚ä∞ yl} p = congruence‚ÇÇ(_‚ä∞_)
      (injective(f) ([‚àß]-elim‚Çó([‚ä∞]-generalized-cancellation p)))
      (proof {xl} {yl} ([‚àß]-elim·µ£([‚ä∞]-generalized-cancellation p)))

module _
  ‚¶É equiv-A : Equiv{‚Ñì‚Çë‚ÇÅ}(A) ‚¶Ñ ‚¶É equiv-List‚ÇÅ : Equiv{‚Ñì‚Çë‚Çó‚ÇÅ}(List(A)) ‚¶Ñ ‚¶É extensionality-A : Extensionality(equiv-List‚ÇÅ) ‚¶Ñ
  ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ
  where

  private variable _‚ñ´‚ÇÅ_ _‚ñ´‚ÇÇ_ : A ‚Üí B ‚Üí B
  private variable id‚ÇÅ id‚ÇÇ : T
  private variable l l‚ÇÅ l‚ÇÇ : List(T)

  fold·µ£-operator-raw : ‚àÄ ‚¶É oper‚ÇÅ : BinaryOperator(_‚ñ´‚ÇÅ_) ‚¶Ñ ‚Üí (‚àÄ{x y} ‚Üí (x ‚ñ´‚ÇÅ y) ‚â° (x ‚ñ´‚ÇÇ y)) ‚Üí (id‚ÇÅ ‚â° id‚ÇÇ) ‚Üí (l‚ÇÅ ‚â° l‚ÇÇ) ‚Üí (fold·µ£(_‚ñ´‚ÇÅ_) id‚ÇÅ l‚ÇÅ ‚â° fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ l‚ÇÇ)
  fold·µ£-operator-raw {l‚ÇÅ = ‚àÖ} {l‚ÇÇ = ‚àÖ} op-eq id-eq l-eq = id-eq
  fold·µ£-operator-raw {l‚ÇÅ = ‚àÖ} {l‚ÇÇ = x ‚ä∞ l‚ÇÇ} op-eq id-eq l-eq with () ‚Üê [‚àÖ][‚ä∞]-unequal l-eq
  fold·µ£-operator-raw {l‚ÇÅ = x ‚ä∞ l‚ÇÅ} {l‚ÇÇ = ‚àÖ} op-eq id-eq l-eq with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) l-eq)
  fold·µ£-operator-raw {_‚ñ´‚ÇÅ_ = _‚ñ´‚ÇÅ_} {_‚ñ´‚ÇÇ_ = _‚ñ´‚ÇÇ_} {id‚ÇÅ}{id‚ÇÇ} {x‚ÇÅ ‚ä∞ l‚ÇÅ} {x‚ÇÇ ‚ä∞ l‚ÇÇ} op-eq id-eq l-eq =
    fold·µ£(_‚ñ´‚ÇÅ_) id‚ÇÅ (x‚ÇÅ ‚ä∞ l‚ÇÅ) üùñ[ _‚â°_ ]-[]
    x‚ÇÅ ‚ñ´‚ÇÅ fold·µ£(_‚ñ´‚ÇÅ_) id‚ÇÅ l‚ÇÅ üùñ[ _‚â°_ ]-[ congruence‚ÇÇ(_‚ñ´‚ÇÅ_) ([‚ä∞]-generalized-cancellation·µ£ l-eq) (fold·µ£-operator-raw {l‚ÇÅ = l‚ÇÅ}{l‚ÇÇ = l‚ÇÇ} op-eq id-eq ([‚ä∞]-generalized-cancellation‚Çó l-eq)) ]
    x‚ÇÇ ‚ñ´‚ÇÅ fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ l‚ÇÇ üùñ[ _‚â°_ ]-[ op-eq ]
    x‚ÇÇ ‚ñ´‚ÇÇ fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ l‚ÇÇ üùñ[ _‚â°_ ]-[]
    fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ (x‚ÇÇ ‚ä∞ l‚ÇÇ) üùñ-end

module _ ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ ‚¶É equiv-C : Equiv{‚Ñì‚Çë‚ÇÉ}(C) ‚¶Ñ where
  private variable _‚ñ´_ : B ‚Üí C ‚Üí C
  private variable f : A ‚Üí B
  private variable id : C

  fold·µ£-map-preserve : ‚¶É oper : BinaryOperator(_‚ñ´_) ‚¶Ñ ‚Üí ‚àÄ{l} ‚Üí (fold·µ£((_‚ñ´_) ‚àò f) id l ‚â° fold·µ£(_‚ñ´_) id (map f(l)))
  fold·µ£-map-preserve                  {l = ‚àÖ}     = reflexivity(_‚â°_)
  fold·µ£-map-preserve{_‚ñ´_ = _‚ñ´_}{f = f}{l = x ‚ä∞ l} = congruence‚ÇÇ·µ£(_‚ñ´_)(f(x)) (fold·µ£-map-preserve{_‚ñ´_ = _‚ñ´_}{f = f}{l = l})

module _ ‚¶É equiv-B : Equiv{‚Ñì‚Çë}(Option(B)) ‚¶Ñ where
  private variable f : A ‚Üí B
  private variable l : List(A)

  first-preserve-map : first(map f(l)) ‚â° Option.map f(first l)
  first-preserve-map {l = ‚àÖ}     = reflexivity(_‚â°_)
  first-preserve-map {l = _ ‚ä∞ _} = reflexivity(_‚â°_)
