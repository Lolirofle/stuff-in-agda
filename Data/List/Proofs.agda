module Data.List.Proofs where

import Lvl
open import Function.EqualsRaw
open import Functional as Fn using (_‚àò_ ; const)
open import Data.Option using (Option ; Some ; None)
import      Data.Option.Functions as Option
open import Data.List
open import Data.List.Equiv
open import Data.List.Functions
open import Logic
open import Logic.Propositional
open import Numeral.Natural
open import Numeral.Natural.Oper
open import Numeral.Natural.Oper.Proofs
open import Relator.Equals renaming (_‚â°_ to _‚â°‚Çë_ ; _‚â¢_ to _‚â¢‚Çë_)
open import Structure.Function
open import Structure.Function.Domain
open import Structure.Function.Multi
import      Structure.Function.Names as Names
import      Structure.Operator.Names as Names
open import Structure.Operator.Proofs.Util
open import Structure.Operator.Properties
open import Structure.Operator
open import Structure.Relator.Properties
open import Structure.Setoid
open import Syntax.Transitivity
open import Type

private variable ‚Ñì ‚Ñì‚Çë ‚Ñì‚Çë‚Çó ‚Ñì‚Çë‚Çí ‚Ñì‚Çë‚ÇÅ ‚Ñì‚Çë‚ÇÇ ‚Ñì‚Çë‚ÇÉ ‚Ñì‚Çë‚ÇÑ ‚Ñì‚Çë‚Çó‚ÇÅ ‚Ñì‚Çë‚Çó‚ÇÇ ‚Ñì‚Çë‚Çó‚ÇÉ : Lvl.Level
private variable T A B C D A‚ÇÅ A‚ÇÇ B‚ÇÅ B‚ÇÇ : Type{‚Ñì}
private variable n : ‚Ñï

module _ ‚¶É equiv : Equiv{‚Ñì‚Çë}(T) ‚¶Ñ ‚¶É equiv-List : Equiv{‚Ñì‚Çë‚Çó}(List(T)) ‚¶Ñ ‚¶É extensionality : Extensionality(equiv-List) ‚¶Ñ where
  private variable l l‚ÇÅ l‚ÇÇ l‚Çë : List(T)
  private variable a b x e : T
  private variable P : List(T) ‚Üí Stmt{‚Ñì}
  private variable _‚ñ´_ : A ‚Üí B ‚Üí C

  open Equiv(equiv-List) using () renaming (_‚â°_ to _‚â°‚Çó_)

  instance
    tail-function : Function(tail)
    Function.congruence tail-function {‚àÖ}      {‚àÖ}      p = p
    Function.congruence tail-function {‚àÖ}      {x ‚ä∞ y}  p with () ‚Üê [‚àÖ][‚ä∞]-unequal p
    Function.congruence tail-function {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) p)
    Function.congruence tail-function {x ‚ä∞ xl} {y ‚ä∞ yl} p = [‚ä∞]-generalized-cancellation‚Çó p

  instance
    first-function : ‚¶É equiv-Option : Equiv{‚Ñì‚Çë‚Çí}(Option(T)) ‚¶Ñ ‚¶É Some-function : Function(Some) ‚¶Ñ ‚Üí Function(first)
    Function.congruence first-function {‚àÖ}      {‚àÖ}      p = reflexivity(_‚â°_)
    Function.congruence first-function {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ][‚ä∞]-unequal p
    Function.congruence first-function {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) p)
    Function.congruence first-function {x ‚ä∞ xl} {y ‚ä∞ yl} p = congruence‚ÇÅ(Some) ([‚ä∞]-generalized-cancellation·µ£ p)

  instance
    [‚ä∞]-cancellation‚Çó : Cancellation‚Çó(_‚ä∞_)
    Cancellation‚Çó.proof([‚ä∞]-cancellation‚Çó) = [‚ä∞]-generalized-cancellation‚Çó

  instance
    [‚ä∞]-cancellation·µ£ : Cancellation·µ£(_‚ä∞_)
    Cancellation·µ£.proof([‚ä∞]-cancellation·µ£) = [‚ä∞]-generalized-cancellation·µ£

  [‚ä∞]-unequal : (x ‚ä∞ l ‚â¢ l)
  [‚ä∞]-unequal {l = ‚àÖ} = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)
  [‚ä∞]-unequal {l = x ‚ä∞ l} = [‚ä∞]-unequal {l = l} ‚àò [‚ä∞]-generalized-cancellation‚Çó

  instance
    [++]-identity‚Çó : Identity‚Çó(_++_) ‚àÖ
    Identity‚Çó.proof([++]-identity‚Çó) = reflexivity(_‚â°_)

  instance
    [++]-identity·µ£ : Identity·µ£(_++_) ‚àÖ
    Identity·µ£.proof([++]-identity·µ£) {x = l} = elim _ (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(x) {l ++ ‚àÖ}{l}) l

  instance
    [++]-associativity : Associativity(_++_)
    Associativity.proof([++]-associativity) {l‚ÇÅ}{l‚ÇÇ}{l‚ÇÉ} = elim _ (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(x) {(l ++ l‚ÇÇ) ++ l‚ÇÉ}{l ++ (l‚ÇÇ ++ l‚ÇÉ)}) l‚ÇÅ

  instance
    [++]-function : BinaryOperator(_++_)
    [++]-function = intro p where
      p : Names.Congruence‚ÇÇ(_++_)
      p {‚àÖ}      {‚àÖ}      {x‚ÇÇ} {y‚ÇÇ} xy‚ÇÅ xy‚ÇÇ = xy‚ÇÇ
      p {‚àÖ}      {b ‚ä∞ y‚ÇÅ} {x‚ÇÇ} {y‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÅ
      p {a ‚ä∞ x‚ÇÅ} {‚àÖ}      {x‚ÇÇ} {y‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) xy‚ÇÅ)
      p {a ‚ä∞ x‚ÇÅ} {b ‚ä∞ y‚ÇÅ} {x‚ÇÇ} {y‚ÇÇ} xy‚ÇÅ xy‚ÇÇ = congruence‚ÇÇ(_‚ä∞_) ([‚ä∞]-generalized-cancellation·µ£ xy‚ÇÅ) (p{x‚ÇÅ}{y‚ÇÅ}{x‚ÇÇ}{y‚ÇÇ} ([‚ä∞]-generalized-cancellation‚Çó xy‚ÇÅ) xy‚ÇÇ)

  prepend-[++] : (a ‚ä∞ l ‚â° singleton{T = T}(a) ++ l)
  prepend-[++] = reflexivity(_‚â°_)

  postpend-[++] : (postpend{T = T} a l ‚â° l ++ singleton(a))
  postpend-[++] {a = a}{l = l} = elim _ (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(x) {postpend a l}{l ++ (singleton a)}) l

  postpend-of-[++] : (postpend{T = T} a (l‚ÇÅ ++ l‚ÇÇ) ‚â° l‚ÇÅ ++ postpend a l‚ÇÇ)
  postpend-of-[++] {a = a} {l‚ÇÅ}{l‚ÇÇ} = elim _ (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(x) {postpend a (l ++ l‚ÇÇ)}{l ++ (postpend a l‚ÇÇ)}) l‚ÇÅ

  fold‚Çó-of-postpend : (fold‚Çó(_‚ñ´_) e (postpend x l) ‚â° (fold‚Çó(_‚ñ´_) e l) ‚ñ´ x)
  fold‚Çó-of-postpend {l = ‚àÖ}     = reflexivity(_‚â°_)
  fold‚Çó-of-postpend {l = x ‚ä∞ l} = fold‚Çó-of-postpend {l = l}

  [‚àò]-commutativity-of-postpend-prepend : postpend a ‚àò prepend b ‚äú prepend b ‚àò postpend a
  [‚àò]-commutativity-of-postpend-prepend = reflexivity(_‚â°_)

  fold‚Çó-[‚ä±]-move-to-end : fold‚Çó(_‚ä±_) l‚Çë l ‚â° (fold‚Çó(_‚ä±_) ‚àÖ l) ++ l‚Çë
  fold‚Çó-[‚ä±]-move-to-end {l‚Çë} {‚àÖ} = identity‚Çó(_++_)(‚àÖ)
  fold‚Çó-[‚ä±]-move-to-end {l‚Çë} {x ‚ä∞ l} =
    fold‚Çó(_‚ä±_) l‚Çë (x ‚ä∞ l)             üùñ[ _‚â°_ ]-[]
    fold‚Çó(_‚ä±_) (x ‚ä∞ l‚Çë) l             üùñ[ _‚â°_ ]-[ fold‚Çó-[‚ä±]-move-to-end {x ‚ä∞ l‚Çë} {l} ]
    fold‚Çó(_‚ä±_) ‚àÖ l ++ (x ‚ä∞ l‚Çë)        üùñ[ _‚â°_ ]-[]
    fold‚Çó(_‚ä±_) ‚àÖ l ++ ((x ‚ä∞ ‚àÖ) ++ l‚Çë) üùñ[ _‚â°_ ]-[ associativity(_++_) {fold‚Çó(_‚ä±_) ‚àÖ l} ]-sym
    (fold‚Çó(_‚ä±_) ‚àÖ l ++ (x ‚ä∞ ‚àÖ)) ++ l‚Çë üùñ[ _‚â°_ ]-[ congruence‚ÇÇ-‚ÇÅ(_++_)(l‚Çë) (fold‚Çó-[‚ä±]-move-to-end {x ‚ä∞ ‚àÖ} {l}) ]-sym
    fold‚Çó(_‚ä±_) (x ‚ä∞ ‚àÖ) l ++ l‚Çë        üùñ[ _‚â°_ ]-[]
    fold‚Çó(_‚ä±_) ‚àÖ (x ‚ä∞ l) ++ l‚Çë        üùñ-end

  instance
    postpend-function : BinaryOperator(postpend)
    postpend-function = intro p where
      p : Names.Congruence‚ÇÇ(postpend)
      p {x‚ÇÇ = ‚àÖ}        {y‚ÇÇ = ‚àÖ}        px pl = congruence‚ÇÇ(_‚ä∞_) px pl
      p {x‚ÇÇ = ‚àÖ}        {y‚ÇÇ = y‚ÇÇ ‚ä∞ yl‚ÇÇ} px pl with () ‚Üê [‚àÖ][‚ä∞]-unequal pl
      p {x‚ÇÇ = x‚ÇÇ ‚ä∞ xl‚ÇÇ} {y‚ÇÇ = ‚àÖ}        px pl with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) pl)
      p {x‚ÇÇ = x‚ÇÇ ‚ä∞ xl‚ÇÇ} {y‚ÇÇ = y‚ÇÇ ‚ä∞ yl‚ÇÇ} px pl = congruence‚ÇÇ(_‚ä∞_) ([‚ä∞]-generalized-cancellation·µ£ pl) (p{x‚ÇÇ = xl‚ÇÇ} {y‚ÇÇ = yl‚ÇÇ} px ([‚ä∞]-generalized-cancellation‚Çó pl))

  [‚àÖ]-postpend-unequal : (postpend x l ‚â¢ ‚àÖ)
  [‚àÖ]-postpend-unequal {l = ‚àÖ}     = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)
  [‚àÖ]-postpend-unequal {l = _ ‚ä∞ l} = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)

  postpend-unequal : (postpend x l ‚â¢ l)
  postpend-unequal {l = ‚àÖ}     = [‚àÖ][‚ä∞]-unequal ‚àò symmetry(_‚â°_)
  postpend-unequal {l = y ‚ä∞ l} = postpend-unequal {l = l} ‚àò cancellation‚Çó(_‚ä∞_)

  [++]-middle-prepend-postpend : postpend x l‚ÇÅ ++ l‚ÇÇ ‚â° l‚ÇÅ ++ (x ‚ä∞ l‚ÇÇ)
  [++]-middle-prepend-postpend {l‚ÇÅ = ‚àÖ}      {l‚ÇÇ = ‚àÖ} = reflexivity(_‚â°_)
  [++]-middle-prepend-postpend {l‚ÇÅ = ‚àÖ}      {l‚ÇÇ = x ‚ä∞ l‚ÇÇ} = reflexivity(_‚â°_)
  [++]-middle-prepend-postpend {l‚ÇÅ = x ‚ä∞ l‚ÇÅ} {l‚ÇÇ = l‚ÇÇ} = congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(x) ([++]-middle-prepend-postpend {l‚ÇÅ = l‚ÇÅ} {l‚ÇÇ = l‚ÇÇ})

  instance
    [++]-cancellation‚Çó : Cancellation‚Çó(_++_)
    Cancellation‚Çó.proof [++]-cancellation‚Çó {x}{y}{z} = proof {x}{y}{z} where
      proof : Names.Cancellation‚Çó (_++_)
      proof {‚àÖ}     p = p
      proof {x ‚ä∞ l} p = proof {l} (cancellation‚Çó(_‚ä∞_) p)

  instance
    [++]-cancellation·µ£ : Cancellation·µ£(_++_)
    Cancellation·µ£.proof([++]-cancellation·µ£) {a}{b} = proof {a}{b} where
      proof : Names.Cancellation·µ£(_++_)
      proof {z}      {‚àÖ}      {‚àÖ}      p = reflexivity(_‚â°_)
      proof {z}      {x ‚ä∞ xl} {y ‚ä∞ yl} p = congruence‚ÇÇ(_‚ä∞_) ([‚ä∞]-generalized-cancellation·µ£ p) (proof {z}{xl}{yl} ([‚ä∞]-generalized-cancellation‚Çó p))
      proof {‚àÖ}      {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ][‚ä∞]-unequal {l = yl} (p üùñ identity·µ£(_++_)(‚àÖ))
      proof {z ‚ä∞ zl} {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ]-postpend-unequal(symmetry(_‚â°_) (proof{zl}{‚àÖ}{postpend z yl} ([‚ä∞]-generalized-cancellation‚Çó p üùñ symmetry(_‚â°_) ([++]-middle-prepend-postpend {x = z}{l‚ÇÅ = yl}{l‚ÇÇ = zl}))))
      proof {‚àÖ}      {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal {l = xl} (symmetry(_‚â°_) p üùñ identity·µ£(_++_)(‚àÖ))
      proof {z ‚ä∞ zl} {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ]-postpend-unequal(proof{zl}{postpend z xl}{‚àÖ} ([++]-middle-prepend-postpend {x = z}{l‚ÇÅ = xl}{l‚ÇÇ = zl} üùñ [‚ä∞]-generalized-cancellation‚Çó p))

  initial-of-‚àÖ : (initial(n)(‚àÖ {T = T}) ‚â° ‚àÖ)
  initial-of-‚àÖ {n = ùüé}    = reflexivity(_‚â°_)
  initial-of-‚àÖ {n = ùêí(n)} = reflexivity(_‚â°_)


  module _ where
    open import Relator.Equals.Proofs.Equiv
    fold·µ£-constant-[+]·µ£ : ‚àÄ{init step} ‚Üí (fold·µ£ (const(_+ step)) init l ‚â°‚Çë (step ‚ãÖ length(l)) + init)
    fold·µ£-constant-[+]·µ£ {l = ‚àÖ} = reflexivity(_‚â°‚Çë_)
    fold·µ£-constant-[+]·µ£ {l = x ‚ä∞ l} {init}{step} =
      const(_+ step) x (fold·µ£ (const(_+ step)) init l) üùñ[ _‚â°_ ]-[]
      (fold·µ£ (const(_+ step)) init l) + step           üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(_+ step) (fold·µ£-constant-[+]·µ£ {l = l} {init}{step}) ]
      ((step ‚ãÖ length(l)) + init) + step               üùñ[ _‚â°_ ]-[ One.commute·µ£-assoc‚Çó {a = step ‚ãÖ length(l)}{init}{step} ]
      ((step ‚ãÖ length(l)) + step) + init               üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(_+ init) (commutativity(_+_) {step ‚ãÖ length(l)}{step}) ]
      (step + (step ‚ãÖ length(l))) + init               üùñ-end

    fold·µ£-constant-[+]‚Çó : ‚àÄ{init step} ‚Üí (fold·µ£ (const(step +_)) init l ‚â° (length(l) ‚ãÖ step) + init)
    fold·µ£-constant-[+]‚Çó {l = ‚àÖ}                  = reflexivity(_‚â°_)
    fold·µ£-constant-[+]‚Çó {l = x ‚ä∞ l} {init}{step} =
      fold·µ£(const(step +_)) init (x ‚ä∞ l)  üùñ[ _‚â°_ ]-[]
      step + fold·µ£(const(step +_)) init l üùñ[ _‚â°_ ]-[ congruence‚ÇÇ-‚ÇÇ(_+_)(step) (fold·µ£-constant-[+]‚Çó {l = l} {init}{step}) ]
      step + ((length(l) ‚ãÖ step) + init)  üùñ[ _‚â°_ ]-[ associativity(_+_) {step}{length(l) ‚ãÖ step}{init} ]-sym
      (step + (length(l) ‚ãÖ step)) + init  üùñ[ _‚â°_ ]-[ congruence‚ÇÇ-‚ÇÅ(_+_)(init) (commutativity(_+_) {step}{length(l) ‚ãÖ step}) ]
      ((length(l) ‚ãÖ step) + step) + init  üùñ[ _‚â°_ ]-[ congruence‚ÇÇ-‚ÇÅ(_+_)(init) ([‚ãÖ]-with-[ùêí]‚Çó {length(l)}{step}) ]-sym
      (ùêí(length(l)) ‚ãÖ step) + init        üùñ[ _‚â°_ ]-[]
      (length(x ‚ä∞ l) ‚ãÖ step) + init       üùñ-end

  instance
    [++^]-identity·µ£ : Identity·µ£(_++^_ {T = T})(ùüè)
    [++^]-identity·µ£ = intro p where
      p : Names.Identity·µ£(_++^_)(ùüè)
      p{‚àÖ}     = reflexivity(_‚â°_)
      p{x ‚ä∞ l} = congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(x) (p{l})

  fold·µ£-inverse : fold·µ£(_‚ä∞_) ‚àÖ ‚äú Fn.id
  fold·µ£-inverse {‚àÖ}     = reflexivity(_‚â°_)
  fold·µ£-inverse {x ‚ä∞ l} = congruence‚ÇÇ-‚ÇÇ(prepend)(x) (fold·µ£-inverse {l})

module _
  ‚¶É equiv-A : Equiv{‚Ñì‚Çë‚ÇÅ}(A) ‚¶Ñ ‚¶É equiv-List‚ÇÅ : Equiv{‚Ñì‚Çë‚Çó‚ÇÅ}(List(A)) ‚¶Ñ ‚¶É extensionality-A : Extensionality(equiv-List‚ÇÅ) ‚¶Ñ
  ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ ‚¶É equiv-List‚ÇÇ : Equiv{‚Ñì‚Çë‚Çó‚ÇÇ}(List(B)) ‚¶Ñ ‚¶É extensionality-B : Extensionality(equiv-List‚ÇÇ) ‚¶Ñ
  where

  private variable l l‚ÇÅ l‚ÇÇ : List(T)
  private variable a b x : T
  private variable P : List(T) ‚Üí Stmt{‚Ñì}

  private variable f g : A ‚Üí B

  map-postpend : (map f(postpend a l) ‚â° postpend (f(a)) (map f(l)))
  map-postpend {f = f} {a = a}{l = l} = elim _ (reflexivity(_‚â°_)) (\x l ‚Üí congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(f(x)) {map f (postpend a l)}{postpend (f(a)) (map f l)}) l

  instance
    map-preserves-[++] : Preserving‚ÇÇ(map f)(_++_)(_++_)
    Preserving.proof (map-preserves-[++] {f = f}) {l‚ÇÅ} {l‚ÇÇ} = elim _ (reflexivity(_‚â°_)) (\x l‚ÇÅ ‚Üí congruence‚ÇÇ-‚ÇÇ(_‚ä∞_)(f(x)) {map f(l‚ÇÅ ++ l‚ÇÇ)}{(map f l‚ÇÅ) ++ (map f l‚ÇÇ)}) l‚ÇÅ

  open import Logic.Propositional
  open import Syntax.Implication

  module _ ‚¶É func-fg : Function(f) ‚à® Function(g) ‚¶Ñ where
    map-operator-raw : (f ‚äú g) ‚Üí (l‚ÇÅ ‚â° l‚ÇÇ) ‚Üí (map f(l‚ÇÅ) ‚â° map g(l‚ÇÇ))
    map-operator-raw {‚àÖ}       {‚àÖ}       fg xy = reflexivity(_‚â°_)
    map-operator-raw {‚àÖ}       {x‚ÇÇ ‚ä∞ l‚ÇÇ} fg xy with () ‚Üê [‚àÖ][‚ä∞]-unequal xy
    map-operator-raw {x‚ÇÅ ‚ä∞ l‚ÇÅ} {‚àÖ}       fg xy with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) xy)
    map-operator-raw {x‚ÇÅ ‚ä∞ l‚ÇÅ} {x‚ÇÇ ‚ä∞ l‚ÇÇ} fg xy =
      ‚Ä¢ ([‚à®]-elim
        (\func-f ‚Üí let instance _ = func-f in
          f(x‚ÇÅ) üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(f) ([‚àß]-elim‚Çó([‚ä∞]-generalized-cancellation xy)) ]
          f(x‚ÇÇ) üùñ[ _‚â°_ ]-[ fg {x‚ÇÇ} ]
          g(x‚ÇÇ) üùñ-end
        )
        (\func-g ‚Üí let instance _ = func-g in
          f(x‚ÇÅ) üùñ[ _‚â°_ ]-[ fg {x‚ÇÅ} ]
          g(x‚ÇÅ) üùñ[ _‚â°_ ]-[ congruence‚ÇÅ(g) ([‚àß]-elim‚Çó([‚ä∞]-generalized-cancellation xy)) ]
          g(x‚ÇÇ) üùñ-end
        )
        func-fg
      )
      ‚Ä¢ (
        map f(l‚ÇÅ) üùñ[ _‚â°_ ]-[ map-operator-raw fg ([‚àß]-elim·µ£([‚ä∞]-generalized-cancellation xy)) ]
        map g(l‚ÇÇ) üùñ-end
      )
      ‚áí‚ÇÇ-[ congruence‚ÇÇ(_‚ä∞_) ]
      (f(x‚ÇÅ) ‚ä∞ map f(l‚ÇÅ) ‚â° g(x‚ÇÇ) ‚ä∞ map g(l‚ÇÇ)) ‚áí-end

    map-functional-raw : (f ‚äú g) ‚Üí (map f ‚äú map g)
    map-functional-raw fg = map-operator-raw fg (reflexivity(_‚â°_))

  instance
    map-function : ‚¶É func-f : Function(f) ‚¶Ñ ‚Üí Function(map f)
    map-function {f = f} ‚¶É func-f ‚¶Ñ = intro (map-operator-raw ‚¶É [‚à®]-intro‚Çó func-f ‚¶Ñ (reflexivity(_‚äú_) {f}))

  map-injective : ‚¶É inj : Injective(f) ‚¶Ñ ‚Üí Injective(map f)
  map-injective {f = f} = intro proof where
    proof : Names.Injective(map f)
    proof {‚àÖ}      {‚àÖ}      p = reflexivity(_‚â°_)
    proof {‚àÖ}      {y ‚ä∞ yl} p with () ‚Üê [‚àÖ][‚ä∞]-unequal p
    proof {x ‚ä∞ xl} {‚àÖ}      p with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) p)
    proof {x ‚ä∞ xl} {y ‚ä∞ yl} p = congruence‚ÇÇ(_‚ä∞_)
      (injective(f) ([‚àß]-elim‚Çó([‚ä∞]-generalized-cancellation p)))
      (proof {xl} {yl} ([‚àß]-elim·µ£([‚ä∞]-generalized-cancellation p)))

module _
  ‚¶É equiv-A : Equiv{‚Ñì‚Çë‚ÇÅ}(A) ‚¶Ñ ‚¶É equiv-List‚ÇÅ : Equiv{‚Ñì‚Çë‚Çó‚ÇÅ}(List(A)) ‚¶Ñ ‚¶É extensionality-A : Extensionality(equiv-List‚ÇÅ) ‚¶Ñ
  ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ
  where

  private variable _‚ñ´‚ÇÅ_ _‚ñ´‚ÇÇ_ : A ‚Üí B ‚Üí B
  private variable id‚ÇÅ id‚ÇÇ : T
  private variable l l‚ÇÅ l‚ÇÇ : List(T)

  fold·µ£-operator-raw : ‚àÄ ‚¶É oper‚ÇÅ : BinaryOperator(_‚ñ´‚ÇÅ_) ‚¶Ñ ‚Üí ((_‚ñ´‚ÇÅ_) ‚äú (_‚ñ´‚ÇÇ_)) ‚Üí (id‚ÇÅ ‚â° id‚ÇÇ) ‚Üí (l‚ÇÅ ‚â° l‚ÇÇ) ‚Üí (fold·µ£(_‚ñ´‚ÇÅ_) id‚ÇÅ l‚ÇÅ ‚â° fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ l‚ÇÇ)
  fold·µ£-operator-raw {l‚ÇÅ = ‚àÖ} {l‚ÇÇ = ‚àÖ} op-eq id-eq l-eq = id-eq
  fold·µ£-operator-raw {l‚ÇÅ = ‚àÖ} {l‚ÇÇ = x ‚ä∞ l‚ÇÇ} op-eq id-eq l-eq with () ‚Üê [‚àÖ][‚ä∞]-unequal l-eq
  fold·µ£-operator-raw {l‚ÇÅ = x ‚ä∞ l‚ÇÅ} {l‚ÇÇ = ‚àÖ} op-eq id-eq l-eq with () ‚Üê [‚àÖ][‚ä∞]-unequal (symmetry(_‚â°_) l-eq)
  fold·µ£-operator-raw {_‚ñ´‚ÇÅ_ = _‚ñ´‚ÇÅ_} {_‚ñ´‚ÇÇ_ = _‚ñ´‚ÇÇ_} {id‚ÇÅ}{id‚ÇÇ} {x‚ÇÅ ‚ä∞ l‚ÇÅ} {x‚ÇÇ ‚ä∞ l‚ÇÇ} op-eq id-eq l-eq =
    fold·µ£(_‚ñ´‚ÇÅ_) id‚ÇÅ (x‚ÇÅ ‚ä∞ l‚ÇÅ) üùñ[ _‚â°_ ]-[]
    x‚ÇÅ ‚ñ´‚ÇÅ fold·µ£(_‚ñ´‚ÇÅ_) id‚ÇÅ l‚ÇÅ üùñ[ _‚â°_ ]-[ congruence‚ÇÇ(_‚ñ´‚ÇÅ_) ([‚ä∞]-generalized-cancellation·µ£ l-eq) (fold·µ£-operator-raw {l‚ÇÅ = l‚ÇÅ}{l‚ÇÇ = l‚ÇÇ} op-eq id-eq ([‚ä∞]-generalized-cancellation‚Çó l-eq)) ]
    x‚ÇÇ ‚ñ´‚ÇÅ fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ l‚ÇÇ üùñ[ _‚â°_ ]-[ op-eq ]
    x‚ÇÇ ‚ñ´‚ÇÇ fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ l‚ÇÇ üùñ[ _‚â°_ ]-[]
    fold·µ£(_‚ñ´‚ÇÇ_) id‚ÇÇ (x‚ÇÇ ‚ä∞ l‚ÇÇ) üùñ-end

module _ ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ ‚¶É equiv-C : Equiv{‚Ñì‚Çë‚ÇÉ}(C) ‚¶Ñ where
  private variable _‚ñ´_ : B ‚Üí C ‚Üí C
  private variable f : A ‚Üí B
  private variable id : C

  fold·µ£-map-preserve : ‚¶É oper : BinaryOperator(_‚ñ´_) ‚¶Ñ ‚Üí (fold·µ£((_‚ñ´_) ‚àò f) id ‚äú fold·µ£(_‚ñ´_) id ‚àò map f)
  fold·µ£-map-preserve                  {x = ‚àÖ}     = reflexivity(_‚â°_)
  fold·µ£-map-preserve{_‚ñ´_ = _‚ñ´_}{f = f}{x = x ‚ä∞ l} = congruence‚ÇÇ-‚ÇÇ(_‚ñ´_)(f(x)) (fold·µ£-map-preserve{_‚ñ´_ = _‚ñ´_}{f = f}{x = l})

module _ ‚¶É equiv : Equiv{‚Ñì‚Çë}(T) ‚¶Ñ  where
  private variable _‚ñ´_ : T ‚Üí T ‚Üí T
  private variable f : T ‚Üí T
  private variable id : T

  -- Note: When f is (_‚ñ´ y) for an arbitrary y, preserv of type (‚àÄ{x y} ‚Üí Preserving‚ÇÅ (_‚ñ´ y) (x ‚ñ´_)(x ‚ñ´_)) is associativity.
  -- Examples:
  --   ùêí(fold·µ£(_+_) ùüé l) = fold·µ£(_+_) ùüè l
  --   (fold·µ£(_+_) 5 l) + 10 = fold·µ£(_+_) 15 l
  --   f(fold·µ£(_‚ñ´_) id [a,b,c,d]) = f(a ‚ñ´ (b ‚ñ´ (c ‚ñ´ d))) = a ‚ñ´ f(b ‚ñ´ (c ‚ñ´ d)) = a ‚ñ´ (b ‚ñ´ f(c ‚ñ´ d)) =  = a ‚ñ´ (b ‚ñ´ (c ‚ñ´ f(d))) = fold·µ£(_‚ñ´_) (f(id)) [a,b,c,d]
  fold·µ£-outer-composition : ‚¶É oper : BinaryOperator(_‚ñ´_) ‚¶Ñ ‚¶É preserv : ‚àÄ{x} ‚Üí Preserving‚ÇÅ f (x ‚ñ´_)(x ‚ñ´_) ‚¶Ñ ‚Üí ‚àÄ{l} ‚Üí (f(fold·µ£(_‚ñ´_) id l) ‚â° fold·µ£(_‚ñ´_) (f(id)) l)
  fold·µ£-outer-composition                            {l = ‚àÖ}     = reflexivity(_‚â°_)
  fold·µ£-outer-composition {_‚ñ´_ = _‚ñ´_}{f = f}{id = id}{l = x ‚ä∞ l} =
    f(fold·µ£(_‚ñ´_) id (x ‚ä∞ l))   üùñ[ _‚â°_ ]-[]
    f(x ‚ñ´ fold·µ£(_‚ñ´_) id l)     üùñ[ _‚â°_ ]-[ preserving‚ÇÅ f (x ‚ñ´_)(x ‚ñ´_) ]
    x ‚ñ´ f(fold·µ£(_‚ñ´_) id l)     üùñ[ _‚â°_ ]-[ congruence‚ÇÇ-‚ÇÇ(_‚ñ´_)(x) (fold·µ£-outer-composition{l = l}) ]
    x ‚ñ´ (fold·µ£(_‚ñ´_) (f(id)) l) üùñ[ _‚â°_ ]-[]
    fold·µ£(_‚ñ´_) (f(id)) (x ‚ä∞ l) üùñ-end

module _ ‚¶É equiv-B : Equiv{‚Ñì‚Çë}(Option(B)) ‚¶Ñ where
  private variable f : A ‚Üí B
  private variable l : List(A)

  first-preserve-map : first(map f(l)) ‚â° Option.map f(first l)
  first-preserve-map {l = ‚àÖ}     = reflexivity(_‚â°_)
  first-preserve-map {l = _ ‚ä∞ _} = reflexivity(_‚â°_)

module _
  ‚¶É equiv-A : Equiv{‚Ñì‚Çë‚ÇÅ}(A) ‚¶Ñ
  ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ
  ‚¶É equiv-C : Equiv{‚Ñì‚Çë‚ÇÉ}(C) ‚¶Ñ
  ‚¶É equiv-List-A : Equiv{‚Ñì‚Çë‚Çó‚ÇÅ}(List(A)) ‚¶Ñ
  ‚¶É equiv-List-B : Equiv{‚Ñì‚Çë‚Çó‚ÇÇ}(List(B)) ‚¶Ñ
  ‚¶É equiv-List-C : Equiv{‚Ñì‚Çë‚Çó‚ÇÉ}(List(C)) ‚¶Ñ
  ‚¶É ext-A : Extensionality(equiv-List-A) ‚¶Ñ
  ‚¶É ext-B : Extensionality(equiv-List-B) ‚¶Ñ
  ‚¶É ext-C : Extensionality(equiv-List-C) ‚¶Ñ
  where

  private variable f : List A ‚Üí List C
  private variable g : List B ‚Üí List C
  private variable _‚ñ´_ : A ‚Üí B ‚Üí C

  instance
    map‚ÇÇ-function : ‚¶É func-f : Function(f) ‚¶Ñ ‚¶É func-g : Function(g) ‚¶Ñ ‚¶É oper : BinaryOperator(_‚ñ´_) ‚¶Ñ ‚Üí BinaryOperator(map‚ÇÇ(_‚ñ´_) f g)
    map‚ÇÇ-function{f = f}{g = g}{_‚ñ´_ = _‚ñ´_} = intro(\{x} ‚Üí p{x}) where
      p : Names.Congruence‚ÇÇ(map‚ÇÇ(_‚ñ´_) f g)
      p{‚àÖ}     {‚àÖ}         {‚àÖ}       {‚àÖ}        xy‚ÇÅ xy‚ÇÇ = reflexivity(_‚â°_)
      p{‚àÖ}     {‚àÖ}         {‚àÖ}       {y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÇ
      p{‚àÖ}     {‚àÖ}         {x‚ÇÇ ‚ä∞ xl‚ÇÇ}{‚àÖ}        xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal(symmetry(_‚â°_) xy‚ÇÇ)
      p{‚àÖ}     {‚àÖ}         {x‚ÇÇ ‚ä∞ xl‚ÇÇ}{y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ = congruence‚ÇÅ(g) xy‚ÇÇ
      p{‚àÖ}     {y‚ÇÅ ‚ä∞ yl‚ÇÅ}  {‚àÖ}       {‚àÖ}        xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÅ
      p{‚àÖ}     {y‚ÇÅ ‚ä∞ yl‚ÇÅ}  {‚àÖ}       {y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÅ
      p{‚àÖ}     {y‚ÇÅ ‚ä∞ yl‚ÇÅ}  {x‚ÇÇ ‚ä∞ xl‚ÇÇ}{‚àÖ}        xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÅ
      p{‚àÖ}     {y‚ÇÅ ‚ä∞ yl‚ÇÅ}  {x‚ÇÇ ‚ä∞ xl‚ÇÇ}{y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÅ
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{‚àÖ}       {‚àÖ}       {‚àÖ}        xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal(symmetry(_‚â°_) xy‚ÇÅ)
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{‚àÖ}       {‚àÖ}       {y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÇ
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{‚àÖ}       {x‚ÇÇ ‚ä∞ xl‚ÇÇ}{‚àÖ}        xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal(symmetry(_‚â°_) xy‚ÇÅ)
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{‚àÖ}       {x‚ÇÇ ‚ä∞ xl‚ÇÇ}{y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal(symmetry(_‚â°_) xy‚ÇÅ)
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{y‚ÇÅ ‚ä∞ yl‚ÇÅ}{‚àÖ}       {‚àÖ}        xy‚ÇÅ xy‚ÇÇ = congruence‚ÇÅ(f) xy‚ÇÅ
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{y‚ÇÅ ‚ä∞ yl‚ÇÅ}{‚àÖ}       {y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal xy‚ÇÇ
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{y‚ÇÅ ‚ä∞ yl‚ÇÅ}{x‚ÇÇ ‚ä∞ xl‚ÇÇ}{‚àÖ}        xy‚ÇÅ xy‚ÇÇ with () ‚Üê [‚àÖ][‚ä∞]-unequal(symmetry(_‚â°_) xy‚ÇÇ)
      p{x‚ÇÅ ‚ä∞ xl‚ÇÅ}{y‚ÇÅ ‚ä∞ yl‚ÇÅ}{x‚ÇÇ ‚ä∞ xl‚ÇÇ}{y‚ÇÇ ‚ä∞ yl‚ÇÇ} xy‚ÇÅ xy‚ÇÇ = congruence‚ÇÇ(_‚ä∞_)
        (congruence‚ÇÇ(_‚ñ´_)
          ([‚ä∞]-generalized-cancellation·µ£ xy‚ÇÅ)
          ([‚ä∞]-generalized-cancellation·µ£ xy‚ÇÇ)
        )
        (p{xl‚ÇÅ}{yl‚ÇÅ}{xl‚ÇÇ}{yl‚ÇÇ}
          ([‚ä∞]-generalized-cancellation‚Çó xy‚ÇÅ)
          ([‚ä∞]-generalized-cancellation‚Çó xy‚ÇÇ)
        )

module _
  ‚¶É equiv-A : Equiv{‚Ñì‚Çë‚ÇÅ}(A) ‚¶Ñ
  ‚¶É equiv-B : Equiv{‚Ñì‚Çë‚ÇÇ}(B) ‚¶Ñ
  ‚¶É equiv-List-A : Equiv{‚Ñì‚Çë‚Çó‚ÇÅ}(List(A)) ‚¶Ñ
  ‚¶É equiv-List-B : Equiv{‚Ñì‚Çë‚Çó‚ÇÇ}(List(B)) ‚¶Ñ
  ‚¶É ext-A : Extensionality(equiv-List-A) ‚¶Ñ
  ‚¶É ext-B : Extensionality(equiv-List-B) ‚¶Ñ
  {f g : A ‚Üí List B}
  ‚¶É func-fg : Function(f) ‚à® Function(g) ‚¶Ñ
  where

  private variable l‚ÇÅ l‚ÇÇ : List A

  concatMap-operator : (f ‚äú g) ‚Üí (l‚ÇÅ ‚â° l‚ÇÇ) ‚Üí (concatMap f l‚ÇÅ ‚â° concatMap g l‚ÇÇ)
  concatMap-operator {l‚ÇÅ = ‚àÖ}      {l‚ÇÇ = ‚àÖ}      pf pl = reflexivity(_‚â°_)
  concatMap-operator {l‚ÇÅ = ‚àÖ}      {l‚ÇÇ = y ‚ä∞ l‚ÇÇ} pf pl with () ‚Üê [‚àÖ][‚ä∞]-unequal pl
  concatMap-operator {l‚ÇÅ = x ‚ä∞ l‚ÇÅ} {l‚ÇÇ = ‚àÖ}      pf pl with () ‚Üê [‚àÖ][‚ä∞]-unequal(symmetry(_‚â°_) pl)
  concatMap-operator {l‚ÇÅ = x ‚ä∞ l‚ÇÅ} {l‚ÇÇ = y ‚ä∞ l‚ÇÇ} pf pl = congruence‚ÇÇ(_++_)
    ([‚à®]-elim
      (\func-f ‚Üí congruence‚ÇÅ(f) ‚¶É func-f ‚¶Ñ ([‚ä∞]-generalized-cancellation·µ£ pl) üùñ pf)
      (\func-g ‚Üí pf üùñ congruence‚ÇÅ(g) ‚¶É func-g ‚¶Ñ ([‚ä∞]-generalized-cancellation·µ£ pl))
      func-fg
    )
    (concatMap-operator {l‚ÇÅ = l‚ÇÅ} {l‚ÇÇ = l‚ÇÇ} pf ([‚ä∞]-generalized-cancellation‚Çó pl))
