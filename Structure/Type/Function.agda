module Structure.Type.Function where

open import BidirectionalFunction using (_‚Üî_ ; _$‚Çó_ ; _$·µ£_ ; intro)
open import Function as Fn using (_‚Üí·∂†_)
open import Function.Equals
import      Lvl
open import Relator.Equals.Proofs.Equiv
open import Type
open import Structure.Function.Domain
open import Structure.Setoid

private variable ‚Ñì ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ ‚Ñì‚ÇÉ ‚Ñì‚Çë : Lvl.Level
private variable T : Type{‚Ñì}

module _ where
  private variable A : Type{‚Ñì}
  private variable B : A ‚Üí Type{‚Ñì}

  record DependentFunctionType(_‚ü∂_ : (A : Type{‚Ñì‚ÇÅ}) ‚Üí (A ‚Üí Type{‚Ñì‚ÇÇ}) ‚Üí Type{‚Ñì‚ÇÉ}) ‚¶É equiv : ‚àÄ{A : Type{‚Ñì‚ÇÅ}}{B : A ‚Üí Type{‚Ñì‚ÇÇ}} ‚Üí Equiv{‚Ñì‚Çë}(A ‚ü∂ B) ‚¶Ñ : Type{Lvl.ùêí(‚Ñì‚ÇÅ Lvl.‚äî ‚Ñì‚ÇÇ) Lvl.‚äî ‚Ñì‚ÇÉ Lvl.‚äî ‚Ñì‚Çë} where
    field
      convert : ((a : A) ‚Üí B(a)) ‚Üî (A ‚ü∂ B)
      correctness : InversePair ‚¶É Dependent.[‚äú]-equiv ‚¶É [‚â°]-equiv ‚¶Ñ ‚¶Ñ ‚¶É equiv{A}{B} ‚¶Ñ convert

    _$_ : (A ‚ü∂ B) ‚Üí (a : A) ‚Üí B(a)
    _$_ = convert $‚Çó_

    lift : ((a : A) ‚Üí B(a)) ‚Üí (A ‚ü∂ B)
    lift = convert $·µ£_

module _ where
  private variable A B C : Type{‚Ñì}

  -- A type isomorphic to the function type, allowing "application" and "abstraction".
  record FunctionType(_‚ü∂_ : Type{‚Ñì‚ÇÅ} ‚Üí Type{‚Ñì‚ÇÇ} ‚Üí Type{‚Ñì‚ÇÉ}) ‚¶É equiv : ‚àÄ{A : Type{‚Ñì‚ÇÅ}}{B : Type{‚Ñì‚ÇÇ}} ‚Üí Equiv{‚Ñì‚Çë}(A ‚ü∂ B) ‚¶Ñ : Type{Lvl.ùêí(‚Ñì‚ÇÅ Lvl.‚äî ‚Ñì‚ÇÇ) Lvl.‚äî ‚Ñì‚ÇÉ Lvl.‚äî ‚Ñì‚Çë} where
    field
      convert : (A ‚Üí B) ‚Üî (A ‚ü∂ B)
      correctness : InversePair ‚¶É Dependent.[‚äú]-equiv ‚¶É [‚â°]-equiv ‚¶Ñ ‚¶Ñ ‚¶É equiv{A}{B} ‚¶Ñ convert

    -- Function application.
    _$_ : (A ‚ü∂ B) ‚Üí A ‚Üí B
    _$_ = convert $‚Çó_

    -- Function abstraction.
    lift : (A ‚Üí B) ‚Üí (A ‚ü∂ B)
    lift = convert $·µ£_

    -- Constant function.
    const : B ‚Üí (A ‚ü∂ B)
    const b = lift(Fn.const b)

  open FunctionType ‚¶É ‚Ä¶ ‚¶Ñ hiding (convert ; correctness) public

  import      Functional as Fn
  open import Relator.Equals

  instance
    explicit-functionType : FunctionType{‚Ñì‚ÇÅ}{‚Ñì‚ÇÇ}(_‚Üí·∂†_)
    FunctionType.convert explicit-functionType = intro(Fn._$_) Fn.id
    Inverse·µ£.proof (InversePair.left  (FunctionType.correctness explicit-functionType)) = [‚â°]-intro
    Inverse·µ£.proof (InversePair.right (FunctionType.correctness explicit-functionType)) = intro [‚â°]-intro

  open import Functional.Implicit as Implicit
  instance
    implicit-functionType : FunctionType{‚Ñì‚ÇÅ}{‚Ñì‚ÇÇ}(_Ôπõ‚ÜíÔπú_)
    FunctionType.convert implicit-functionType = intro(_Ôπõ$Ôπú_) Implicit.inferArg
    Inverse·µ£.proof (InversePair.left  (FunctionType.correctness implicit-functionType)) = [‚â°]-intro
    Inverse·µ£.proof (InversePair.right (FunctionType.correctness implicit-functionType)) = intro [‚â°]-intro

  open import Functional.Instance as Instance
  instance
    instance-functionType : FunctionType{‚Ñì‚ÇÅ}{‚Ñì‚ÇÇ}(_‚¶É‚Üí‚¶Ñ_)
    FunctionType.convert instance-functionType = intro(_‚¶É$‚¶Ñ_) Instance.inferArg
    Inverse·µ£.proof (InversePair.left  (FunctionType.correctness instance-functionType)) = [‚â°]-intro
    Inverse·µ£.proof (InversePair.right (FunctionType.correctness instance-functionType)) = intro [‚â°]-intro
