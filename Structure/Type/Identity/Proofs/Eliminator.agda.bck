module Structure.Type.Identity.Proofs.Eliminator where

import      Lvl
open import Functional using (_â†’á¶ _ ; id ; _onâ‚‚_ ; swap ; apply)
open import Logic
open import Logic.Propositional
open import Logic.Propositional.Proofs.Structures
open import Structure.Categorical.Properties
open import Structure.Function
open import Structure.Operator
open import Structure.Groupoid
open import Structure.Setoid using (Equiv ; intro) renaming (_â‰¡_ to _â‰¡â‚›_)
open import Structure.Relator.Equivalence
open import Structure.Relator.Properties
open import Structure.Relator.Properties.Proofs
open import Structure.Relator
open import Structure.Type.Identity
open import Structure.Type.Identity.Proofs
open import Syntax.Function
open import Syntax.Transitivity hiding (_ğŸ–_)
open import Syntax.Type
open import Type

private variable â„“ â„“â‚ â„“â‚‚ â„“â‚‘â‚ â„“â‚‘â‚‚ â„“â‚‘ â„“â‚˜â‚‘ â„“â‚š â„“â‚’ : Lvl.Level
private variable T A B R : Type{â„“}
private variable x y : T
private variable Id _â‰¡_ _â–«_ : T â†’ T â†’ Stmt{â„“}

module Oper (Id : T â†’ T â†’ Type{â„“â‚‘}) â¦ƒ refl :  Reflexivity(Id) â¦„ â¦ƒ identElim : IdentityEliminator{â„“â‚š = â„“â‚‘}(Id) â¦„ where
  open Symmetry    (identity-eliminator-to-symmetry     {Id = Id}) using () renaming (proof to sym)   public
  open Transitivity(identity-eliminator-to-transitivity {Id = Id}) using () renaming (proof to trans) public
  ftrans = identity-eliminator-to-flipped-transitivityáµ£ â¦ƒ refl â¦„ â¦ƒ identElim â¦„

module Oper2 (Id : A â†’ A â†’ Type{â„“â‚‘}) â¦ƒ refl :  Reflexivity(Id) â¦„ â¦ƒ identElim : IdentityEliminator{â„“â‚š = â„“â‚š}(Id) â¦„ where
  open Reflexivity (refl) using () renaming (proof to refl)  public
  module _ (_â–«_ : A â†’ A â†’ Type{â„“â‚š}) â¦ƒ [â–«]-refl : Reflexivity(_â–«_) â¦„ where
    open _âŠ†â‚‚_ identity-eliminator-to-reflexive-subrelation using () renaming (proof to sub) public
  module _ (_â–«_ : B â†’ B â†’ Type{â„“â‚š}) â¦ƒ [â–«]-refl : Reflexivity(_â–«_) â¦„ (f : A â†’ B) where
    open _âŠ†â‚‚_ (minimal-reflection-transport â¦ƒ minRefl = identity-eliminator-to-reflexive-subrelation â¦„ {_â–«_ = _â–«_} {f = f}) using () renaming (proof to transp) public

module _
  {Id : T â†’ T â†’ Type{â„“â‚‘}} â¦ƒ refl-Id :  Reflexivity(Id) â¦„  â¦ƒ identElim-Id : IdentityEliminator{â„“â‚‘}(Id) â¦„
  {_â‰¡_ : âˆ€{T : Type{â„“â‚‘}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(Id)(_â‰¡_) â¦„
  where
  open Oper(Id)
  open Oper2{â„“â‚š = â„“â‚‘}(Id)

  identity-eliminator-symmetry-of-refl : âˆ€{x} â†’ (sym refl â‰¡ refl{x})
  identity-eliminator-symmetry-of-refl = idElimOfIntro(Id)(_â‰¡_) (\{x y} _ â†’ Id y x) refl

module _
  {Id : T â†’ T â†’ Type{â„“â‚‘â‚}} â¦ƒ refl-T :  Reflexivity(Id) â¦„  â¦ƒ identElim-T : IdentityEliminator{Lvl.of(T)}(Id) â¦„
  {_â‰¡_ : âˆ€{T : Type{â„“â‚‘â‚‚}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(Id)(_â‰¡_) â¦„
  {_â–«_ : T â†’ T â†’ Type{â„“â‚‘â‚‚}} â¦ƒ refl-op : Reflexivity(_â–«_) â¦„
  where
  open Oper2{â„“â‚š = â„“â‚‘â‚‚}(Id)

  identity-eliminator-reflexive-subrelation-of-refl : âˆ€{x} â†’ (sub(_â–«_) refl â‰¡ reflexivity(_â–«_){x})
  identity-eliminator-reflexive-subrelation-of-refl = idElimOfIntro(Id)(_â‰¡_) (\{x y} _ â†’ (x â–« y)) (reflexivity(_â–«_))

module _
  {Id : A â†’ A â†’ Type{â„“â‚‘â‚}} â¦ƒ refl-A :  Reflexivity(Id) â¦„  â¦ƒ identElim-A : IdentityEliminator(Id) â¦„
  {_â‰¡_ : âˆ€{T : Type{â„“â‚‘â‚‚}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(Id)(_â‰¡_) â¦„
  {_â–«_ : B â†’ B â†’ Type{â„“â‚‘â‚‚}} â¦ƒ refl-B : Reflexivity(_â–«_) â¦„
  {f : A â†’ B}
  where
  open Oper2{â„“â‚š = â„“â‚‘â‚‚}(Id)

  identity-eliminator-transport-of-refl : âˆ€{a} â†’ (transp(_â–«_)(f) (refl{a}) â‰¡ reflexivity(_â–«_) {f(a)})
  identity-eliminator-transport-of-refl {a} = identity-eliminator-reflexive-subrelation-of-refl {_â‰¡_ = _â‰¡_} {_â–«_ = (_â–«_) onâ‚‚ f} â¦ƒ onâ‚‚-reflexivity â¦„ {x = a}

module _
  {Id : T â†’ T â†’ Type{â„“â‚‘}}
    â¦ƒ refl-T :  Reflexivity(Id) â¦„
    â¦ƒ identElim-T : IdentityEliminator(Id) â¦„
  {_â‰¡_ : âˆ€{T : Type{â„“â‚‘}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
    â¦ƒ refl-eq : âˆ€{T : Type} â†’ Reflexivity(_â‰¡_ {T = T}) â¦„
    -- â¦ƒ func-apply-refl : âˆ€{x} â†’ Function {A = Id x x â†’ Id x x}{B = Id x x} â¦ƒ {!!} â¦„ â¦ƒ {!!} â¦„ (apply(reflexivity(Id) {x})) â¦„
    â¦ƒ identElim-eq : âˆ€{T : Type} â†’ IdentityEliminator{â„“â‚š = â„“â‚˜â‚‘}(_â‰¡_ {T = T}) â¦„
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(Id)(_â‰¡_) â¦„
  where
  open Reflexivity (refl-T) using () renaming (proof to refl)  public
  open Transitivity(identity-eliminator-to-transitivity {Id = Id}) using () renaming (proof to trans) public
  ftrans = identity-eliminator-to-flipped-transitivityáµ£ â¦ƒ refl-T â¦„ â¦ƒ identElim-T â¦„

  instance _ = identity-eliminator-to-reflexive-subrelation

  -- test : âˆ€{x : T}{f g : Id x x â†’ Id x x} â†’ (f â‰¡ g) â†’ (f refl â‰¡ g refl)
  -- test = {!!}

  identity-eliminator-flipped-transitivityáµ£-of-refl : âˆ€{x} â†’ (ftrans refl refl â‰¡ refl{x})
  identity-eliminator-flipped-transitivityáµ£-of-refl {z} = subâ‚‚(_â‰¡_)((_â‰¡_) onâ‚‚ (apply refl)) â¦ƒ minimal-reflection-transport â¦„ identity-eliminator-transport-of-refl
  -- subâ‚‚(_â‰¡_)((_â‰¡_) onâ‚‚ (apply refl)) â¦ƒ intro test â¦„ identity-eliminator-transport-of-refl
  -- congruenceâ‚‚â‚— â¦ƒ ? â¦„ â¦ƒ ? â¦„ â¦ƒ ? â¦„ (Functional._$_) â¦ƒ ? â¦„ (refl)

  identity-eliminator-transitivity-of-refl : âˆ€{x} â†’ (trans refl refl â‰¡ refl{x})
  identity-eliminator-transitivity-of-refl = transitivity(_â‰¡_) â¦ƒ identity-eliminator-to-transitivity â¦„ p identity-eliminator-flipped-transitivityáµ£-of-refl where
    p : trans refl refl â‰¡ ftrans refl refl
    p = subâ‚‚(_â‰¡_)((_â‰¡_) onâ‚‚ (p â†¦ identity-eliminator-to-flipped-transitivityáµ£ p refl)) â¦ƒ minimal-reflection-transport â¦„ identity-eliminator-symmetry-of-refl

module _
  â¦ƒ equiv-A : Equiv{â„“â‚‘â‚}(A) â¦„
    â¦ƒ identElim-A : IdentityEliminator(Equiv._â‰¡_ equiv-A) â¦„
  â¦ƒ equiv-B : Equiv{â„“â‚‘â‚‚}(B) â¦„
  {_â‰¡â‚˜_ : âˆ€{T : Type{â„“â‚‘â‚‚}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(Equiv._â‰¡_ equiv-A)(_â‰¡â‚˜_) â¦„
  where

  open Reflexivity(Equiv.reflexivity equiv-A) using () renaming (proof to refl-A)
  open Reflexivity(Equiv.reflexivity equiv-B) using () renaming (proof to refl-B)
  instance _ = identity-eliminator-to-reflexive-subrelation
  instance _ = minimal-reflection-to-function

  identity-eliminator-function-of-refl : âˆ€{f : A â†’ B}{a} â†’ (congruenceâ‚(f) (refl-A {a}) â‰¡â‚˜ refl-B {f(a)})
  identity-eliminator-function-of-refl = identity-eliminator-transport-of-refl

module _
  â¦ƒ equiv-T : Equiv{â„“â‚‘â‚}(T) â¦„
    â¦ƒ identElim-T : IdentityEliminator(Equiv._â‰¡_ equiv-T) â¦„
  {_â‰¡â‚˜_ : âˆ€{T : Type{â„“â‚‘â‚‚}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
    â¦ƒ refle-eq : âˆ€{T : Type} â†’ Reflexivity(_â‰¡â‚˜_ {T = T}) â¦„
    â¦ƒ identElim-eq : âˆ€{T : Type} â†’ IdentityEliminator{â„“â‚š = â„“â‚˜â‚‘}(_â‰¡â‚˜_ {T = T}) â¦„
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(Equiv._â‰¡_ equiv-T)(_â‰¡â‚˜_) â¦„
  where

  open Reflexivity(Equiv.reflexivity equiv-T) using () renaming (proof to refl)
  instance _ = identity-eliminator-to-reflexive-subrelation
  instance _ = minimal-reflection-to-relator

  identity-eliminator-relator-of-refl : âˆ€{P : T â†’ Stmt}{x}{p : P(x)} â†’ (substituteâ‚(P) refl p â‰¡â‚˜ p)
  identity-eliminator-relator-of-refl {p = p} = subâ‚‚(_â‰¡â‚˜_)((_â‰¡â‚˜_) onâ‚‚ (apply p)) â¦ƒ minimal-reflection-transport â¦„ identity-eliminator-transport-of-refl
module _
  {_â‰¡_ : T â†’ T â†’ Type{â„“â‚‘}}
    â¦ƒ refl-T :  Reflexivity(_â‰¡_) â¦„
    â¦ƒ identElim-T : âˆ€{â„“â‚š} â†’ IdentityEliminator{â„“â‚š = â„“â‚š}(_â‰¡_) â¦„
  {_â‰¡â‚˜_ : âˆ€{T : Type{â„“â‚‘}} â†’ T â†’ T â†’ Type{â„“â‚˜â‚‘}}
    â¦ƒ eq : âˆ€{T : Type} â†’ Equivalence(_â‰¡â‚˜_ {T = T}) â¦„
  â¦ƒ identElimOfIntro : IdentityEliminationOfIntro(_â‰¡_)(_â‰¡â‚˜_) â¦„
  where

  open Reflexivity (refl-T)                                         using () renaming (proof to refl)
  open Symmetry    (identity-eliminator-to-symmetry     {Id = _â‰¡_}) using () renaming (proof to sym)
  open Transitivity(identity-eliminator-to-transitivity {Id = _â‰¡_}) using () renaming (proof to trans)
  open Transitivity(identity-eliminator-to-transitivity {Id = _â‰¡_}) using () renaming (proof to infix 25 _ğŸ–_)
  instance _ = identity-eliminator-to-reflexive-subrelation
  instance _ = \{T} â†’ Equivalence.reflexivity (eq{T})
  instance _ = \{T} â†’ Equivalence.symmetry    (eq{T})
  instance _ = \{T} â†’ Equivalence.transitivity(eq{T})
  -- instance _ = \{T} â†’ identity-eliminator-to-transitivity {Id = _â‰¡â‚˜_ {T = T}} â¦ƒ refl = refl-eq â¦„ â¦ƒ identElim = identElim-eq â¦„
  -- instance _ = \{T} â†’ Structure.Setoid.intro(_) â¦ƒ identity-eliminator-to-equivalence {Id = _â‰¡â‚˜_ {T = T}} â¦ƒ refl = refl-eq â¦„ â¦ƒ identElim = identElim-eq â¦„ â¦„

  identity-eliminator-identityâ‚— : âˆ€{x y}{p : x â‰¡ y} â†’ (refl ğŸ– p â‰¡â‚˜ p)
  identity-eliminator-identityâ‚— {p = p} = idElim(_â‰¡_) (p â†¦ (refl ğŸ– p â‰¡â‚˜ p)) identity-eliminator-transitivity-of-refl p

  identity-eliminator-identityáµ£ : âˆ€{x y}{p : x â‰¡ y} â†’ (p ğŸ– refl â‰¡â‚˜ p)
  identity-eliminator-identityáµ£ {p = p} = idElim(_â‰¡_) (p â†¦ (p ğŸ– refl â‰¡â‚˜ p)) identity-eliminator-transitivity-of-refl p

  identity-eliminator-associativity : âˆ€{x y z w}{p : x â‰¡ y}{q : y â‰¡ z}{r : z â‰¡ w} â†’ ((p ğŸ– q) ğŸ– r â‰¡â‚˜ p ğŸ– (q ğŸ– r))
  identity-eliminator-associativity {p = p} {q = q} {r = r} =
    idElim(_â‰¡_)
      (p â†¦ âˆ€ q r â†’ ((p ğŸ– q) ğŸ– r â‰¡â‚˜ p ğŸ– (q ğŸ– r)))
      (q â†¦ r â†¦ (
        (refl ğŸ– q) ğŸ– r ğŸ–[ _â‰¡â‚˜_ ]-[ subâ‚‚(_â‰¡â‚˜_)((_â‰¡â‚˜_) onâ‚‚ (_ğŸ– r)) â¦ƒ identity-eliminator-to-reflexive-subrelation â¦ƒ refl = onâ‚‚-reflexivity â¦„ â¦„ identity-eliminator-identityâ‚— ]
        q ğŸ– r          ğŸ–[ _â‰¡â‚˜_ ]-[ identity-eliminator-identityâ‚— ]-sym
        refl ğŸ– (q ğŸ– r) ğŸ–-end
      ))
      p q r

  identity-eliminator-inverseâ‚— : âˆ€{x y}{p : x â‰¡ y} â†’ ((sym p) ğŸ– p â‰¡â‚˜ refl)
  identity-eliminator-inverseâ‚— {p = p} =
    idElim(_â‰¡_)
      (p â†¦ (sym p) ğŸ– p â‰¡â‚˜ refl)
      (
        (sym refl) ğŸ– refl ğŸ–[ _â‰¡â‚˜_ ]-[ identity-eliminator-identityáµ£ ]
        sym refl          ğŸ–[ _â‰¡â‚˜_ ]-[ identity-eliminator-symmetry-of-refl ]
        refl              ğŸ–-end
      )
      p

  identity-eliminator-inverseáµ£ : âˆ€{x y}{p : x â‰¡ y} â†’ (p ğŸ– (sym p) â‰¡â‚˜ refl)
  identity-eliminator-inverseáµ£ {p = p} =
    idElim(_â‰¡_)
      (p â†¦ p ğŸ– (sym p) â‰¡â‚˜ refl)
      (
        refl ğŸ– (sym refl) ğŸ–[ _â‰¡â‚˜_ ]-[ identity-eliminator-identityâ‚— ]
        sym refl              ğŸ–[ _â‰¡â‚˜_ ]-[ identity-eliminator-symmetry-of-refl ]
        refl                  ğŸ–-end
      )
      p

  identity-eliminator-categorical-identityâ‚— : Morphism.Identityâ‚—{Obj = T} (\{x} â†’ swap(trans{x})) (refl)
  identity-eliminator-categorical-identityâ‚— = Morphism.intro identity-eliminator-identityáµ£

  identity-eliminator-categorical-identityáµ£ : Morphism.Identityáµ£{Obj = T} (\{x} â†’ swap(trans{x})) (refl)
  identity-eliminator-categorical-identityáµ£ = Morphism.intro identity-eliminator-identityâ‚—

  identity-eliminator-categorical-identity : Morphism.Identity{Obj = T} (\{x} â†’ swap(trans{x})) (refl)
  identity-eliminator-categorical-identity = [âˆ§]-intro identity-eliminator-categorical-identityâ‚— identity-eliminator-categorical-identityáµ£

  identity-eliminator-categorical-associativity : Morphism.Associativity{Obj = T} (\{x} â†’ swap(trans{x}))
  identity-eliminator-categorical-associativity = Morphism.intro (symmetry(_â‰¡â‚˜_) identity-eliminator-associativity)

  identity-eliminator-categorical-inverterâ‚— : Polymorphism.Inverterâ‚—{Obj = T} (\{x} â†’ swap(trans{x})) (refl) (sym)
  identity-eliminator-categorical-inverterâ‚— = Polymorphism.intro identity-eliminator-inverseáµ£

  identity-eliminator-categorical-inverteráµ£ : Polymorphism.Inverteráµ£{Obj = T} (\{x} â†’ swap(trans{x})) (refl) (sym)
  identity-eliminator-categorical-inverteráµ£ = Polymorphism.intro identity-eliminator-inverseâ‚—

  identity-eliminator-categorical-inverter : Polymorphism.Inverter{Obj = T} (\{x} â†’ swap(trans{x})) (refl) (sym)
  identity-eliminator-categorical-inverter = [âˆ§]-intro identity-eliminator-categorical-inverterâ‚— identity-eliminator-categorical-inverteráµ£

  identity-eliminator-groupoid : Groupoid(_â‰¡_)
  Groupoid._âˆ˜_ identity-eliminator-groupoid = swap(trans)
  Groupoid.id  identity-eliminator-groupoid = refl
  Groupoid.inv identity-eliminator-groupoid = sym
  Groupoid.associativity  identity-eliminator-groupoid = identity-eliminator-categorical-associativity
  Groupoid.identity       identity-eliminator-groupoid = identity-eliminator-categorical-identity
  Groupoid.inverter       identity-eliminator-groupoid = identity-eliminator-categorical-inverter
  Groupoid.binaryOperator identity-eliminator-groupoid = intro a where postulate a : âˆ€{a} â†’ a -- TODO
