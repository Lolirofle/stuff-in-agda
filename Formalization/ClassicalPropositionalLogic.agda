open import Type
open import Logic.Classical as Logic using (Classical)
open import Logic.Predicate as Logic using ()

module Formalization.ClassicalPropositionalLogic โฆ classical : โ{โ} โ Logic.โโ(Classical{โ}) โฆ where

import      Lvl
open import Data
open import Data.Boolean
import      Data.Boolean.Operators
open import Data.Boolean.Stmt
open import Data.Either as Either using (_โ_ ; Left ; Right)
open import Data.Tuple as Tuple using ()
private module BoolOp = Data.Boolean.Operators.Logic
open import Functional
open import Function.Names using (_โ_)
open import Logic
open import Logic.Propositional as Logic using (_โ_)
open import Logic.Propositional.Theorems as Logic using ()
open import Logic.Predicate.Theorems as Logic using ()
open import Relator.Equals
open import Relator.Equals.Proofs
open import Relator.Equals.Proofs.Equiv
open import Sets.PredicateSet using (PredSet ; _โ_ ; _โ_ ; _โช_ ; _โชโข_ ; _โ_ ; _โ_ ; _โ_ ; โ ; [โก]-to-[โ] ; [โก]-to-[โ]) renaming (โข_ to singleton ; _โก_ to _โกโ_)
open        Sets.PredicateSet.BoundedQuantifiers
open import Structure.Relator.Properties
open import Syntax.Function
open import Type.Size.Countable

private variable โโ โ โโ โโ : Lvl.Level

open import Formalization.ClassicalPropositionalLogic.Syntax
open import Formalization.ClassicalPropositionalLogic.Syntax.Proofs
open import Formalization.ClassicalPropositionalLogic.Semantics
open import Formalization.ClassicalPropositionalLogic.Semantics.Proofs
import      Formalization.ClassicalPropositionalLogic.TruthTable as TruthTable

module NaturalDeduction where
  data _โข_ {โ โโ} {P : Type{โโ}} : Formulas(P){โ} โ Formula(P) โ Stmt{Lvl.๐(โโ Lvl.โ โ)}
  {-data Tree {โ โโ} {P : Type{โโ}} : Formula(P) โ Stmt{Lvl.๐(โโ Lvl.โ โ)} where
    [โค]-intro : Tree(โค)

    [โฅ]-intro : โ{ฯ} โ Tree(ฯ) โ Tree(ยฌ ฯ) โ Tree(โฅ)
    [โฅ]-elim  : โ{ฯ} โ Tree(โฅ) โ Tree(ฯ)

    [ยฌ]-intro : โ{ฮ : Formulas(P)}{ฯ} โ ((ฮ โช singleton(ฯ)) โข โฅ) โ Tree(ยฌ ฯ)
    [ยฌ]-elim  : โ{ฮ : Formulas(P)}{ฯ} โ ((ฮ โช singleton(ยฌ ฯ)) โข โฅ) โ Tree(ฯ)

    [โง]-intro : โ{ฯ ฯ} โ Tree(ฯ) โ Tree(ฯ) โ Tree(ฯ โง ฯ)
    [โง]-elimโ : โ{ฯ ฯ} โ Tree(ฯ โง ฯ) โ Tree(ฯ)
    [โง]-elimแตฃ : โ{ฯ ฯ} โ Tree(ฯ โง ฯ) โ Tree(ฯ)

    [โจ]-introโ : โ{ฯ ฯ} โ Tree(ฯ) โ Tree(ฯ โจ ฯ)
    [โจ]-introแตฃ : โ{ฯ ฯ} โ Tree(ฯ) โ Tree(ฯ โจ ฯ)
    [โจ]-elim   : โ{ฮ : Formulas(P)}{ฯ ฯ ฯ} โ ((ฮ โช singleton(ฯ)) โข ฯ) โ ((ฮ โช singleton(ฯ)) โข ฯ) โ Tree(ฯ โจ ฯ) โ Tree(ฯ)

    [โถ]-intro : โ{ฮ : Formulas(P)}{ฯ ฯ} โ ((ฮ โช singleton(ฯ)) โข ฯ) โ Tree(ฯ โถ ฯ)
    [โถ]-elim  : โ{ฮ : Formulas(P)}{ฯ ฯ} โ Tree(ฯ) โ Tree(ฯ โถ ฯ) โ Tree(ฯ)

    [โท]-intro : โ{ฮ : Formulas(P)}{ฯ ฯ} โ ((ฮ โช singleton(ฯ)) โข ฯ) โ ((ฮ โช singleton(ฯ)) โข ฯ) โ Tree(ฯ โท ฯ)
    [โท]-elimโ : โ{ฯ ฯ} โ Tree(ฯ) โ Tree(ฯ โท ฯ) โ Tree(ฯ)
    [โท]-elimแตฃ : โ{ฯ ฯ} โ Tree(ฯ) โ Tree(ฯ โท ฯ) โ Tree(ฯ)
  -}

  data _โข_ where
    direct : โ{ฮ} โ (ฮ โ (ฮ โข_))

    [โค]-intro : โ{ฮ} โ (ฮ โข โค)

    [โฅ]-intro : โ{ฮ}{ฯ} โ (ฮ โข ฯ) โ (ฮ โข (ยฌ ฯ)) โ (ฮ โข โฅ)
    [โฅ]-elim  : โ{ฮ}{ฯ} โ (ฮ โข โฅ) โ (ฮ โข ฯ)

    [ยฌ]-intro : โ{ฮ}{ฯ} โ ((ฮ โช singleton(ฯ)) โข โฅ) โ (ฮ โข (ยฌ ฯ))
    [ยฌ]-elim  : โ{ฮ}{ฯ} โ ((ฮ โช singleton(ยฌ ฯ)) โข โฅ) โ (ฮ โข ฯ)

    [โง]-intro : โ{ฮ}{ฯ ฯ} โ (ฮ โข ฯ) โ (ฮ โข ฯ) โ (ฮ โข (ฯ โง ฯ))
    [โง]-elimโ : โ{ฮ}{ฯ ฯ} โ (ฮ โข (ฯ โง ฯ)) โ (ฮ โข ฯ)
    [โง]-elimแตฃ : โ{ฮ}{ฯ ฯ} โ (ฮ โข (ฯ โง ฯ)) โ (ฮ โข ฯ)

    [โจ]-introโ : โ{ฮ}{ฯ ฯ} โ (ฮ โข ฯ) โ (ฮ โข (ฯ โจ ฯ))
    [โจ]-introแตฃ : โ{ฮ}{ฯ ฯ} โ (ฮ โข ฯ) โ (ฮ โข (ฯ โจ ฯ))
    [โจ]-elim   : โ{ฮ}{ฯ ฯ ฯ} โ ((ฮ โช singleton(ฯ)) โข ฯ) โ ((ฮ โช singleton(ฯ)) โข ฯ) โ (ฮ โข (ฯ โจ ฯ)) โ (ฮ โข ฯ)

    [โถ]-intro : โ{ฮ}{ฯ ฯ} โ ((ฮ โช singleton(ฯ)) โข ฯ) โ (ฮ โข (ฯ โถ ฯ))
    [โถ]-elim  : โ{ฮ}{ฯ ฯ} โ (ฮ โข ฯ) โ (ฮ โข (ฯ โถ ฯ)) โ (ฮ โข ฯ)

    [โท]-intro : โ{ฮ}{ฯ ฯ} โ ((ฮ โช singleton(ฯ)) โข ฯ) โ ((ฮ โช singleton(ฯ)) โข ฯ) โ (ฮ โข (ฯ โท ฯ))
    [โท]-elimโ : โ{ฮ}{ฯ ฯ} โ (ฮ โข ฯ) โ (ฮ โข (ฯ โท ฯ)) โ (ฮ โข ฯ)
    [โท]-elimแตฃ : โ{ฮ}{ฯ ฯ} โ (ฮ โข ฯ) โ (ฮ โข (ฯ โท ฯ)) โ (ฮ โข ฯ)

  {-
  Tree-to-[โข]-tautologies : โ{ฯ} โ Tree(ฯ) โ (โ โข ฯ)
  Tree-to-[โข]-tautologies {.โค} [โค]-intro = [โค]-intro
  Tree-to-[โข]-tautologies {.โฅ} ([โฅ]-intro tฯ tฯโ) =
    ([โฅ]-intro
      (Tree-to-[โข]-tautologies tฯ)
      (Tree-to-[โข]-tautologies tฯโ)
    )
  Tree-to-[โข]-tautologies {ฯ} ([โฅ]-elim tฯ) =
    ([โฅ]-elim
      (Tree-to-[โข]-tautologies tฯ)
    )
  Tree-to-[โข]-tautologies {.(ยฌ _)} ([ยฌ]-intro x) = {!!}
  Tree-to-[โข]-tautologies {ฯ} ([ยฌ]-elim x) = {!!}
  Tree-to-[โข]-tautologies {.(_ โง _)} ([โง]-intro tฯ tฯโ) =
    ([โง]-intro
      (Tree-to-[โข]-tautologies tฯ)
      (Tree-to-[โข]-tautologies tฯโ)
    )
  Tree-to-[โข]-tautologies {ฯ} ([โง]-elimโ tฯ) =
    ([โง]-elimโ
      (Tree-to-[โข]-tautologies tฯ)
    )
  Tree-to-[โข]-tautologies {ฯ} ([โง]-elimแตฃ tฯ) =
    ([โง]-elimแตฃ
      (Tree-to-[โข]-tautologies tฯ)
    )
  Tree-to-[โข]-tautologies {.(_ โจ _)} ([โจ]-introโ tฯ) =
    ([โจ]-introโ
      (Tree-to-[โข]-tautologies tฯ)
    )
  Tree-to-[โข]-tautologies {.(_ โจ _)} ([โจ]-introแตฃ tฯ) =
    ([โจ]-introแตฃ
      (Tree-to-[โข]-tautologies tฯ)
    )
  Tree-to-[โข]-tautologies {ฯ} ([โจ]-elim x xโ tฯ) = {!!}
  Tree-to-[โข]-tautologies {.(_ โถ _)} ([โถ]-intro x) = {!!}
  Tree-to-[โข]-tautologies {ฯ} ([โถ]-elim tฯ tฯโ) =
    ([โถ]-elim
      (Tree-to-[โข]-tautologies tฯ)
      (Tree-to-[โข]-tautologies tฯโ)
    )
  Tree-to-[โข]-tautologies {.(_ โท _)} ([โท]-intro x xโ) = {!!}
  Tree-to-[โข]-tautologies {ฯ} ([โท]-elimโ tฯ tฯโ) =
    ([โท]-elimโ
      (Tree-to-[โข]-tautologies tฯ)
      (Tree-to-[โข]-tautologies tฯโ)
    )
  Tree-to-[โข]-tautologies {ฯ} ([โท]-elimแตฃ tฯ tฯโ) =
    ([โท]-elimแตฃ
      (Tree-to-[โข]-tautologies tฯ)
      (Tree-to-[โข]-tautologies tฯโ)
    )

  Tree-to-[โข] : โ{P : Type{โโ}}{ฮ : Formulas(P)}{ฯ} โ ((ฮ โ Tree) โ Tree(ฯ)) โ (ฮ โข ฯ)
  Tree-to-[โข] {ฮ} {ฯ} t = {!!}
  -}

  private variable P : Type{โโ}
  private variable ฮ ฮโ ฮโ : Formulas(P){โ}
  private variable ฯ ฯ : Formula(P)

  weaken-union-singleton : (ฮโ โ ฮโ) โ (((ฮโ โช singleton(ฯ)) โข_) โ ((ฮโ โช singleton(ฯ)) โข_))

  weaken : (ฮโ โ ฮโ) โ ((ฮโ โข_) โ (ฮโ โข_))
  weaken ฮโฮโ {ฯ}        (direct p)         = direct (ฮโฮโ p)
  weaken ฮโฮโ {.โค}       [โค]-intro          = [โค]-intro
  weaken ฮโฮโ {.โฅ}       ([โฅ]-intro  p q)   = [โฅ]-intro  (weaken ฮโฮโ p) (weaken ฮโฮโ q)
  weaken ฮโฮโ {ฯ}        ([โฅ]-elim   p)     = [โฅ]-elim   (weaken ฮโฮโ p)
  weaken ฮโฮโ {.(ยฌ _)}   ([ยฌ]-intro  p)     = [ยฌ]-intro  (weaken-union-singleton ฮโฮโ p)
  weaken ฮโฮโ {ฯ}        ([ยฌ]-elim   p)     = [ยฌ]-elim   (weaken-union-singleton ฮโฮโ p)
  weaken ฮโฮโ {.(_ โง _)} ([โง]-intro  p q)   = [โง]-intro  (weaken ฮโฮโ p) (weaken ฮโฮโ q)
  weaken ฮโฮโ {ฯ}        ([โง]-elimโ  p)     = [โง]-elimโ  (weaken ฮโฮโ p)
  weaken ฮโฮโ {ฯ}        ([โง]-elimแตฃ  p)     = [โง]-elimแตฃ  (weaken ฮโฮโ p)
  weaken ฮโฮโ {.(_ โจ _)} ([โจ]-introโ p)     = [โจ]-introโ (weaken ฮโฮโ p)
  weaken ฮโฮโ {.(_ โจ _)} ([โจ]-introแตฃ p)     = [โจ]-introแตฃ (weaken ฮโฮโ p)
  weaken ฮโฮโ {ฯ}        ([โจ]-elim   p q r) = [โจ]-elim   (weaken-union-singleton ฮโฮโ p) (weaken-union-singleton ฮโฮโ q) (weaken ฮโฮโ r)
  weaken ฮโฮโ {.(_ โถ _)} ([โถ]-intro  p)     = [โถ]-intro  (weaken-union-singleton ฮโฮโ p)
  weaken ฮโฮโ {ฯ}        ([โถ]-elim   p q)   = [โถ]-elim   (weaken ฮโฮโ p) (weaken ฮโฮโ q)
  weaken ฮโฮโ {.(_ โท _)} ([โท]-intro  p q)   = [โท]-intro  (weaken-union-singleton ฮโฮโ p) (weaken-union-singleton ฮโฮโ q)
  weaken ฮโฮโ {ฯ}        ([โท]-elimโ  p q)   = [โท]-elimโ  (weaken ฮโฮโ p) (weaken ฮโฮโ q)
  weaken ฮโฮโ {ฯ}        ([โท]-elimแตฃ  p q)   = [โท]-elimแตฃ  (weaken ฮโฮโ p) (weaken ฮโฮโ q)

  weaken-union-singleton ฮโฮโ p = weaken (Either.mapLeft ฮโฮโ) p

  weaken-union : (ฮโ โข_) โ ((ฮโ โช ฮโ) โข_)
  weaken-union = weaken Either.Left

  [โต]-intro : ((ฮ โช singleton(ฯ)) โข ฯ) โ (ฮ โข (ฯ โต ฯ))
  [โต]-intro = [โถ]-intro

  [โต]-elim : (ฮ โข ฯ) โ (ฮ โข (ฯ โต ฯ)) โ (ฮ โข ฯ)
  [โต]-elim = [โถ]-elim

  [ยฌยฌ]-elim : (ฮ โข ยฌ(ยฌ ฯ)) โ (ฮ โข ฯ)
  [ยฌยฌ]-elim nnฯ =
    ([ยฌ]-elim
      ([โฅ]-intro
        (direct(Right [โก]-intro))
        (weaken-union nnฯ)
      )
    )

  [ยฌยฌ]-intro : (ฮ โข ฯ) โ (ฮ โข ยฌ(ยฌ ฯ))
  [ยฌยฌ]-intro ฮฯ =
    ([ยฌ]-intro
      ([โฅ]-intro
        (weaken-union ฮฯ)
        (direct (Right [โก]-intro))
      )
    )

  _โฌ_ : Formulas(P){โ} โ Formula(P) โ Stmt
  _โฌ_ = Logic.ยฌ_ โโ _โข_

  [ยฌ]-intro-converse : ((ฮ โช singleton(ฯ)) โข โฅ) โ (ฮ โข (ยฌ ฯ))
  [ยฌ]-intro-converse {ฮ = ฮ}{ฯ = ฯ} ฮยฌฯ = [โฅ]-intro (direct (Right [โก]-intro)) (weaken-union ฮยฌฯ)

  excluded-middle : ฮ โข (ฯ โจ (ยฌ ฯ))
  excluded-middle =
    ([ยฌยฌ]-elim
      ([ยฌ]-intro
        ([โฅ]-intro
          ([โจ]-introแตฃ
            ([ยฌ]-intro
              ([โฅ]-intro
                ([โจ]-introโ (direct (Right [โก]-intro)))
                (direct (Left (Right [โก]-intro)))
              )
            )
          )
          (direct (Right [โก]-intro))
        )
      )
    )

  [โ]-disjunctive-form : (ฮ โข (ฯ โถ ฯ)) Logic.โ (ฮ โข ((ยฌ ฯ) โจ ฯ))
  [โ]-disjunctive-form = Logic.[โ]-intro l r where
    l = [โจ]-elim
      ([โถ]-intro ([โฅ]-elim ([โฅ]-intro
        (direct (Right [โก]-intro))
        (direct (Left (Right [โก]-intro)))
      )))
      ([โถ]-intro (direct (Left (Right [โก]-intro))))
    r = pq โฆ
      ([โจ]-elim
        ([โจ]-introแตฃ ([โถ]-elim (direct (Right [โก]-intro)) (weaken Left pq)))
        ([โจ]-introโ (direct (Right [โก]-intro)))
        excluded-middle
      )

  [โท]-negated : (ฮ โข (ฯ โท ฯ)) โ (ฮ โข ((ยฌ ฯ) โท (ยฌ ฯ)))
  [โท]-negated p = [โท]-intro
    ([ยฌ]-intro ([โฅ]-intro ([โท]-elimแตฃ (direct (Right [โก]-intro)) (weaken (Left โ Left) p)) (direct (Left (Right [โก]-intro)))))
    (([ยฌ]-intro ([โฅ]-intro ([โท]-elimโ (direct (Right [โก]-intro)) (weaken (Left โ Left) p)) (direct (Left (Right [โก]-intro))))))

  [โท]-conjunction-disjunction-negation : (ฮ โข (ฯ โท ฯ)) Logic.โ (ฮ โข ((ฯ โง ฯ) โจ ((ยฌ ฯ) โง (ยฌ ฯ))))
  [โท]-conjunction-disjunction-negation = Logic.[โ]-intro l r where
    l = [โจ]-elim
      ([โท]-intro
        ([โง]-elimโ (direct (Left (Right [โก]-intro))))
        ([โง]-elimแตฃ (direct (Left (Right [โก]-intro))))
      )
      ([โท]-intro
        ([โฅ]-elim ([โฅ]-intro (direct (Right [โก]-intro)) ([โง]-elimแตฃ (direct (Left (Right [โก]-intro))))))
        ([โฅ]-elim ([โฅ]-intro (direct (Right [โก]-intro)) ([โง]-elimโ (direct (Left (Right [โก]-intro))))))
      )
    r = p โฆ [โจ]-elim
      ([โจ]-introโ ([โง]-intro
        (direct (Right [โก]-intro))
        ([โท]-elimแตฃ (direct (Right [โก]-intro)) (weaken Left p))
      ))
      ([โจ]-introแตฃ ([โง]-intro
        (direct (Right [โก]-intro))
        ([โท]-elimแตฃ (direct (Right [โก]-intro)) (weaken Left ([โท]-negated p)))
      ))
      excluded-middle

  Inconsistent : Formulas(P){โ} โ Stmt
  Inconsistent(ฮ) = ฮ โข โฅ

  Consistent : Formulas(P){โ} โ Stmt
  Consistent(ฮ) = ฮ โฌ โฅ 

  consistency-of-[โช]โ : Consistent(ฮโ โช ฮโ) โ Consistent(ฮโ)
  consistency-of-[โช]โ con z = con (weaken-union z)

  -- TODO: Replace all occurrences of "consistence" with "consistency", and "deriviability" with "derivability"
  [โข]-deriviability-inconsistence : (ฮ โข ฯ) Logic.โ Inconsistent(ฮ โช singleton(ยฌ ฯ))
  [โข]-deriviability-inconsistence = Logic.[โ]-intro [ยฌ]-elim ([ยฌ]-intro-converse โ [ยฌยฌ]-intro)

  [โข]-deriviability-consistenceแตฃ : Consistent(ฮ) โ ((ฮ โข ฯ) โ Consistent(ฮ โช singleton(ฯ)))
  [โข]-deriviability-consistenceแตฃ con ฮฯ ฮฯโฅ = con([โฅ]-intro ฮฯ ([ยฌ]-intro ฮฯโฅ))

  [โข]-explosion-inconsistence : (โ{ฯ} โ (ฮ โข ฯ)) Logic.โ Inconsistent(ฮ)
  [โข]-explosion-inconsistence {ฮ} = Logic.[โ]-intro (ฮป z โ [โฅ]-elim z) (ฮป z โ z)

  [โข]-functionโ : (ฮโ โกโ ฮโ) โ ((ฮโ โข_) โกโ (ฮโ โข_))
  [โข]-functionโ ฮโฮโ = Logic.[โ]-intro (weaken (Logic.[โ]-to-[โ] ฮโฮโ)) (weaken (Logic.[โ]-to-[โ] ฮโฮโ))

  [โข]-compose : (ฮ โข ฯ) โ ((ฮ โช singleton(ฯ)) โข ฯ) โ (ฮ โข ฯ)
  [โข]-compose ฮฯ ฮฯฯ = [โจ]-elim ฮฯฯ ฮฯฯ ([โจ]-introโ ฮฯ)

  [โข]-compose-inconsistence : (ฮ โข ฯ) โ Inconsistent(ฮ โช singleton(ฯ)) โ Inconsistent(ฮ)
  [โข]-compose-inconsistence ฮฯ ฮฯโฅ = [โฅ]-intro ฮฯ ([ยฌ]-intro ฮฯโฅ)

  [โข]-compose-consistence : (ฮ โข ฯ) โ Consistent(ฮ) โ Consistent(ฮ โช singleton(ฯ))
  [โข]-compose-consistence ฮฯ = Logic.contrapositiveแตฃ ([โข]-compose-inconsistence ฮฯ)

  [โข]-subset-consistency : (ฮโ โ ฮโ) โ (Consistent(ฮโ) โ Consistent(ฮโ))
  [โข]-subset-consistency sub con = con โ weaken sub

  [โข]-subset-inconsistency : (ฮโ โ ฮโ) โ (Inconsistent(ฮโ) โ Inconsistent(ฮโ))
  [โข]-subset-inconsistency sub = weaken sub

  [โฌ]-derives-negation-consistency : (ฮ โฌ (ยฌ ฯ)) โ Consistent(ฮ โช singleton(ฯ))
  [โฌ]-derives-negation-consistency = _โ [ยฌ]-intro

  -- TODO: Is this provable? Does one need to include it in the definition of (_โข_)? Is it even possible to include it?
  -- [โข]-hypothesis : ((ฮ โข ฯ) โ (ฮ โข ฯ)) โ ((ฮ โช singleton(ฯ)) โข ฯ)
  -- [โข]-hypothesis hyp = {!!}

  [โข][โ]-intro-from-[โจ] : (ฮ โข ยฌ ฯ) Logic.โจ (ฮ โข ฯ) โ (ฮ โข (ฯ โถ ฯ))
  [โข][โ]-intro-from-[โจ] {ฮ = ฮ}{ฯ}{ฯ} (Left x) = [โถ]-intro ([โฅ]-elim ([โฅ]-intro (direct (Right [โก]-intro)) (weaken-union {ฮโ = singleton ฯ} x)))
  [โข][โ]-intro-from-[โจ] (Right x) = [โถ]-intro (weaken-union x)

  [ยฌ]-maximal-membershipแตฃ : Consistent(ฮ) โ ((ยฌ ฯ) โ ฮ) โ (ฯ โ ฮ)
  [ยฌ]-maximal-membershipแตฃ con ฮยฌฯ ฮฯ = con([โฅ]-intro (direct ฮฯ) (direct ฮยฌฯ))

  -- A smallest finite set of assumptions that is able to derive a formula.
  finiteAssumptions : โ{ฯ : Formula(P)} โ (ฮ โข ฯ) โ Formulas(P){Lvl.of(P)}
  finiteAssumptions {ฯ = ฯ}        (direct _)                  = singleton(ฯ)
  finiteAssumptions {ฯ = .โค}       [โค]-intro                   = โ
  finiteAssumptions {ฯ = .โฅ}       ([โฅ]-intro           p q)   = finiteAssumptions p โช finiteAssumptions q
  finiteAssumptions {ฯ = ฯ}        ([โฅ]-elim            p)     = finiteAssumptions p
  finiteAssumptions {ฯ = ยฌ ฯ}      ([ยฌ]-intro{ฯ = ฯ}    p)     = finiteAssumptions p โ singleton(ฯ)
  finiteAssumptions {ฯ = ฯ}        ([ยฌ]-elim {ฯ = ฯ}    p)     = finiteAssumptions p โ singleton(ยฌ ฯ)
  finiteAssumptions {ฯ = .(_ โง _)} ([โง]-intro           p q)   = finiteAssumptions p โช finiteAssumptions q
  finiteAssumptions {ฯ = ฯ}        ([โง]-elimโ           p)     = finiteAssumptions p
  finiteAssumptions {ฯ = ฯ}        ([โง]-elimแตฃ           p)     = finiteAssumptions p
  finiteAssumptions {ฯ = .(_ โจ _)} ([โจ]-introโ          p)     = finiteAssumptions p
  finiteAssumptions {ฯ = .(_ โจ _)} ([โจ]-introแตฃ          p)     = finiteAssumptions p
  finiteAssumptions {ฯ = _}        ([โจ]-elim {ฯ = ฯ}{ฯ} p q r) = ((finiteAssumptions p โ singleton(ฯ)) โช (finiteAssumptions q โ singleton(ฯ))) โช finiteAssumptions r
  finiteAssumptions {ฯ = .(_ โถ _)} ([โถ]-intro{ฯ = ฯ}    p)     = finiteAssumptions p โ singleton(ฯ)
  finiteAssumptions {ฯ = ฯ}        ([โถ]-elim            p q)   = finiteAssumptions p โช finiteAssumptions q
  finiteAssumptions {ฯ = .(_ โท _)} ([โท]-intro{ฯ = ฯ}{ฯ} p q)   = (finiteAssumptions p โ singleton(ฯ)) โช (finiteAssumptions q โ singleton(ฯ))
  finiteAssumptions {ฯ = ฯ}        ([โท]-elimโ           p q)   = finiteAssumptions p โช finiteAssumptions q
  finiteAssumptions {ฯ = ฯ}        ([โท]-elimแตฃ           p q)   = finiteAssumptions p โช finiteAssumptions q

  -- TODO: These should be in SetLike
  module _ where
    private variable X : Type{โ}
    private variable A Aโ Aโ B Bโ Bโ C : X โ Type{โ}

    [โช]-subset : (A โ C) โ (B โ C) โ ((A โช B) โ C)
    [โช]-subset ac bc = Logic.[โจ]-elim ac bc

    [โช]-subset2 : (Aโ โ Aโ) โ (Bโ โ Bโ) โ ((Aโ โช Bโ) โ (Aโ โช Bโ))
    [โช]-subset2 aa bb = Logic.[โจ]-elim2 aa bb

    [โ][โช]-is-[โช] : (((A โ B) โช B) โกโ (A โช B))
    [โ][โช]-is-[โช] {A = A}{B = B}{x = x} =
      Logic.[โ]-intro
        (Logic.[โจ]-elim (Ax โฆ Logic.[โจ]-elim2 (Logic.[โง]-intro Ax) id (Logic.[โจ]-symmetry(Logic.excluded-middle(B(x))))) Logic.[โจ]-introแตฃ)
        (Logic.[โจ]-elim (Logic.[โจ]-introโ โ Logic.[โง]-elimโ) Logic.[โจ]-introแตฃ) -- TODO: This direction does not require a classical setting

    [โช][โ]-invertแตฃ-[โ] : (A โ (B โช C)) โ ((A โ C) โ B)
    [โช][โ]-invertแตฃ-[โ] abc (Logic.[โง]-intro a nc) = Logic.[โจ]-elim id (Logic.[โฅ]-elim โ nc) (abc a)

  finiteAssumptions-correctness : (p : (ฮ โข ฯ)) โ (finiteAssumptions p โข ฯ)
  finiteAssumptions-correctness (direct x)         = direct [โก]-intro
  finiteAssumptions-correctness [โค]-intro          = [โค]-intro
  finiteAssumptions-correctness ([โฅ]-intro  p q)   = [โฅ]-intro (weaken Left (finiteAssumptions-correctness p)) (weaken Right (finiteAssumptions-correctness q))
  finiteAssumptions-correctness ([โฅ]-elim   p)     = [โฅ]-elim (finiteAssumptions-correctness p)
  finiteAssumptions-correctness ([ยฌ]-intro  p)     = [ยฌ]-intro (weaken (Logic.[โ]-to-[โ] ([โ][โช]-is-[โช] {A = finiteAssumptions p}{B = singleton _}) โ Logic.[โจ]-introโ) (finiteAssumptions-correctness p))
  finiteAssumptions-correctness ([ยฌ]-elim   p)     = [ยฌ]-elim (weaken (Logic.[โ]-to-[โ] ([โ][โช]-is-[โช] {A = finiteAssumptions p}{B = singleton _}) โ Logic.[โจ]-introโ) (finiteAssumptions-correctness p))
  finiteAssumptions-correctness ([โง]-intro  p q)   = [โง]-intro (weaken Left (finiteAssumptions-correctness p)) (weaken Right (finiteAssumptions-correctness q))
  finiteAssumptions-correctness ([โง]-elimโ  p)     = [โง]-elimโ (finiteAssumptions-correctness p)
  finiteAssumptions-correctness ([โง]-elimแตฃ  p)     = [โง]-elimแตฃ (finiteAssumptions-correctness p)
  finiteAssumptions-correctness ([โจ]-introโ p)     = [โจ]-introโ (finiteAssumptions-correctness p)
  finiteAssumptions-correctness ([โจ]-introแตฃ p)     = [โจ]-introแตฃ (finiteAssumptions-correctness p)
  finiteAssumptions-correctness ([โจ]-elim{ฯ = ฯ}{ฯ} p q r) = [โจ]-elim (weaken (sl โ Left) (finiteAssumptions-correctness p)) (weaken (sr โ Left) (finiteAssumptions-correctness q)) (weaken Right (finiteAssumptions-correctness r)) where
    postulate sl : (finiteAssumptions p โช singleton(ฯ)) โ ((((finiteAssumptions p โ singleton(ฯ)) โช (finiteAssumptions q โ singleton(ฯ))) โช finiteAssumptions r) โช singleton(ฯ))
    postulate sr : (finiteAssumptions q โช singleton(ฯ)) โ ((((finiteAssumptions p โ singleton(ฯ)) โช (finiteAssumptions q โ singleton(ฯ))) โช finiteAssumptions r) โช singleton(ฯ))
  finiteAssumptions-correctness ([โถ]-intro  p)     = [โถ]-intro (weaken (Logic.[โ]-to-[โ] ([โ][โช]-is-[โช] {A = finiteAssumptions p}{B = singleton _}) โ Logic.[โจ]-introโ) (finiteAssumptions-correctness p))
  finiteAssumptions-correctness ([โถ]-elim   p q)   = [โถ]-elim (weaken Left (finiteAssumptions-correctness p)) (weaken Right (finiteAssumptions-correctness q))
  finiteAssumptions-correctness ([โท]-intro  p q)   = [โท]-intro (weaken (sl โ Left) (finiteAssumptions-correctness p)) (weaken (sr โ Left) (finiteAssumptions-correctness q)) where
    postulate sl : (finiteAssumptions p โช singleton(ฯ)) โ (((finiteAssumptions p โ singleton(ฯ)) โช (finiteAssumptions q โ singleton(ฯ))) โช singleton(ฯ))
    postulate sr : (finiteAssumptions q โช singleton(ฯ)) โ (((finiteAssumptions p โ singleton(ฯ)) โช (finiteAssumptions q โ singleton(ฯ))) โช singleton(ฯ))
  finiteAssumptions-correctness ([โท]-elimโ  p q)   = [โท]-elimโ (weaken Left (finiteAssumptions-correctness p)) (weaken Right (finiteAssumptions-correctness q))
  finiteAssumptions-correctness ([โท]-elimแตฃ  p q)   = [โท]-elimแตฃ (weaken Left (finiteAssumptions-correctness p)) (weaken Right (finiteAssumptions-correctness q))

  finiteAssumptions-subset : (p : (ฮ โข ฯ)) โ (finiteAssumptions p โ ฮ)
  finiteAssumptions-subset        (direct x)         = \{[โก]-intro โ x}
  finiteAssumptions-subset        [โค]-intro          = empty
  finiteAssumptions-subset        ([โฅ]-intro  p q)   = [โช]-subset (\{x} โ finiteAssumptions-subset p {x}) (\{x} โ finiteAssumptions-subset q {x})
  finiteAssumptions-subset        ([โฅ]-elim   p)     = finiteAssumptions-subset p
  finiteAssumptions-subset        ([ยฌ]-intro  p)     = [โช][โ]-invertแตฃ-[โ] {A = finiteAssumptions p} (finiteAssumptions-subset p)
  finiteAssumptions-subset        ([ยฌ]-elim   p)     = [โช][โ]-invertแตฃ-[โ] {A = finiteAssumptions p} (finiteAssumptions-subset p)
  finiteAssumptions-subset        ([โง]-intro  p q)   = [โช]-subset (\{x} โ finiteAssumptions-subset p {x}) (\{x} โ finiteAssumptions-subset q {x})
  finiteAssumptions-subset        ([โง]-elimโ  p)     = finiteAssumptions-subset p
  finiteAssumptions-subset        ([โง]-elimแตฃ  p)     = finiteAssumptions-subset p
  finiteAssumptions-subset        ([โจ]-introโ p)     = finiteAssumptions-subset p
  finiteAssumptions-subset        ([โจ]-introแตฃ p)     = finiteAssumptions-subset p
  finiteAssumptions-subset{ฮ = ฮ} ([โจ]-elim   p q r) = [โช]-subset (\{x} โ [โช]-subset{C = ฮ} ([โช][โ]-invertแตฃ-[โ] {B = ฮ} (finiteAssumptions-subset p)) ([โช][โ]-invertแตฃ-[โ] {B = ฮ} (finiteAssumptions-subset q)) {x}) (finiteAssumptions-subset r)
  finiteAssumptions-subset        ([โถ]-intro  p)     = \{(Logic.[โง]-intro fpx ฯx) โ Logic.[โจ]-elim id (Logic.[โฅ]-elim โ ฯx) (finiteAssumptions-subset p fpx)}
  finiteAssumptions-subset        ([โถ]-elim   p q)   = [โช]-subset (\{x} โ finiteAssumptions-subset p {x}) (\{x} โ finiteAssumptions-subset q {x})
  finiteAssumptions-subset        ([โท]-intro  p q)   = Logic.[โจ]-elim ([โช][โ]-invertแตฃ-[โ] {A = finiteAssumptions p} (finiteAssumptions-subset p)) ([โช][โ]-invertแตฃ-[โ] {A = finiteAssumptions q} (finiteAssumptions-subset q))
  finiteAssumptions-subset        ([โท]-elimโ  p q)   = [โช]-subset (\{x} โ finiteAssumptions-subset p {x}) (\{x} โ finiteAssumptions-subset q {x})
  finiteAssumptions-subset        ([โท]-elimแตฃ  p q)   = [โช]-subset (\{x} โ finiteAssumptions-subset p {x}) (\{x} โ finiteAssumptions-subset q {x})

  {-
  module _ where
    open import Numeral.Natural

    finiteAssumptions-index : (p : (ฮ โข ฯ)) โ โ{x} โ (x โ finiteAssumptions p) โ โ
    finiteAssumptions-index (direct x) [โก]-intro = {!!}
    finiteAssumptions-index [โค]-intro ()
    finiteAssumptions-index ([โฅ]-intro p q) (Left x) = {!!}
    finiteAssumptions-index ([โฅ]-intro p q) (Right x) = {!!}
    finiteAssumptions-index ([โฅ]-elim p) = {!!}
    finiteAssumptions-index ([ยฌ]-intro p) = {!!}
    finiteAssumptions-index ([ยฌ]-elim p) = {!!}
    finiteAssumptions-index ([โง]-intro p pโ) = {!!}
    finiteAssumptions-index ([โง]-elimโ p) = {!!}
    finiteAssumptions-index ([โง]-elimแตฃ p) = {!!}
    finiteAssumptions-index ([โจ]-introโ p) = {!!}
    finiteAssumptions-index ([โจ]-introแตฃ p) = {!!}
    finiteAssumptions-index ([โจ]-elim p pโ pโ) = {!!}
    finiteAssumptions-index ([โถ]-intro p) = {!!}
    finiteAssumptions-index ([โถ]-elim p pโ) = {!!}
    finiteAssumptions-index ([โท]-intro p pโ) = {!!}
    finiteAssumptions-index ([โท]-elimโ p pโ) = {!!}
    finiteAssumptions-index ([โท]-elimแตฃ p pโ) = {!!}
  -}

  module _ (ฮ : Formulas(P){โ}) where
    ConsistentSubsetMaximality  = โ{ฮ : Formulas(P){Lvl.of(P) Lvl.โ โ}} โ Consistent(ฮ) โ (ฮ โ ฮ) โ (ฮ โ ฮ)
    ConsistentElementMaximality = โ{ฯ} โ Consistent(ฮ โช singleton(ฯ)) โ (ฯ โ ฮ)
    CompleteDerivability        = โ{ฯ} โ (ฮ โข ฯ) Logic.โจ (ฮ โข (ยฌ ฯ))
    CompleteMembership          = โ{ฯ} โ (ฯ โ ฮ) Logic.โจ ((ยฌ ฯ) โ ฮ)

    -- Equivalences when `ฮ` is consistent. Used in the definition of `MaximallyConsistent`.
    data ConsistentlyComplete : Stmt{Lvl.๐(Lvl.of(P) Lvl.โ โ)} where
      subset-intro          : ConsistentSubsetMaximality  โ ConsistentlyComplete
      element-intro         : ConsistentElementMaximality โ ConsistentlyComplete
      complete-deriv-intro  : CompleteDerivability        โ ConsistentlyComplete
      complete-member-intro : CompleteMembership          โ ConsistentlyComplete

    module CompleteMembership(p : CompleteMembership) where
      consistentSubsetMaximality : ConsistentSubsetMaximality
      consistentSubsetMaximality conฮ ฮฮ {ฯ} ฯฮ = Logic.[โจ]-not-right (p{ฯ}) (ยฌฯฮ โฆ conฮ([โฅ]-intro (direct ฯฮ) (direct(ฮฮ ยฌฯฮ))))

    module ConsistentElementMaximality(element-maximal : ConsistentElementMaximality) where
      consistentSubsetMaximality : ConsistentSubsetMaximality
      consistentSubsetMaximality conฮ ฮฮ {ฯ} ฯฮ = element-maximal ([โข]-subset-consistency (Logic.[โจ]-elim ฮฮ (\{([โก]-intro) โ ฯฮ})) conฮ)

      element-maximal-contra : (ฯ โ ฮ) โ Inconsistent(ฮ โช singleton(ฯ))
      element-maximal-contra = Logic.[โ]-to-[โ] Logic.contrapositive-variant2 element-maximal

      [โข]-deriviability-consistenceโ : ((ฮ โข ฯ) โ Consistent(ฮ โช singleton(ฯ)))
      [โข]-deriviability-consistenceโ = direct โ element-maximal

      module Consistent(consistent : Consistent(ฮ)) where
        [โข]-to-[โ] : (ฮ โข ฯ) โ (ฯ โ ฮ)
        [โข]-to-[โ] = Logic.[โ]-from-contrary (\ฮฯ ฯโฮ โ consistent ([โข]-compose-inconsistence ฮฯ (element-maximal-contra ฯโฮ)))

        [โข][โ]-equivalence : (ฮ โข ฯ) Logic.โ (ฯ โ ฮ)
        [โข][โ]-equivalence = Logic.[โ]-intro direct [โข]-to-[โ]

        -- [โข]-maximal-membership : ((โข p) โ ฮ) Logic.โ ?
        -- [โข]-maximal-membership = 

        [โค]-maximal-membership : (โค โ ฮ) Logic.โ Logic.โค
        [โค]-maximal-membership = Logic.[โ]-intro l r where
          l = const (element-maximal (ฮโค-incons โฆ consistent([โข]-compose-inconsistence [โค]-intro ฮโค-incons)))
          r = const Logic.[โค]-intro

        [โฅ]-maximal-membership : (โฅ โ ฮ) Logic.โ Logic.โฅ
        [โฅ]-maximal-membership = Logic.[โ]-intro l r where
          l = Logic.[โฅ]-elim
          r = consistent โ direct

        [ยฌ]-maximal-membership : ((ยฌ ฯ) โ ฮ) Logic.โ (ฯ โ ฮ)
        [ยฌ]-maximal-membership = Logic.[โ]-intro l r where
          l = [โข]-to-[โ] โ [ยฌ]-intro โ element-maximal-contra
          r = [ยฌ]-maximal-membershipแตฃ consistent

        [โง]-maximal-membership : ((ฯ โง ฯ) โ ฮ) Logic.โ ((ฯ โ ฮ) Logic.โง (ฯ โ ฮ))
        [โง]-maximal-membership = Logic.[โ]-intro l r where
          l = \{(Logic.[โง]-intro ฯฮ ฯฮ) โ [โข]-to-[โ] ([โง]-intro (direct ฯฮ) (direct ฯฮ))}
          r = ฯฯฮ โฆ Logic.[โง]-intro ([โข]-to-[โ] ([โง]-elimโ(direct ฯฯฮ))) ([โข]-to-[โ] ([โง]-elimแตฃ(direct ฯฯฮ)))

        [โจ]-maximal-membership : ((ฯ โจ ฯ) โ ฮ) Logic.โ ((ฯ โ ฮ) Logic.โจ (ฯ โ ฮ))
        [โจ]-maximal-membership = Logic.[โ]-intro l r where
          l = Logic.[โจ]-elim ([โข]-to-[โ] โ [โจ]-introโ โ direct) ([โข]-to-[โ] โ [โจ]-introแตฃ โ direct)
          r = Logic.contrapositiveโ โฆ classical โฆ ((\{(Logic.[โง]-intro ยฌฯฮ ยฌฯฮ) โ ฯฯฮ โฆ consistent([โจ]-elim (element-maximal-contra ยฌฯฮ) (element-maximal-contra ยฌฯฮ) (direct ฯฯฮ))}) โ Logic.[โ]-to-[โ] Logic.[ยฌ]-preserves-[โจ][โง])

        [โถ]-maximal-membership : ((ฯ โถ ฯ) โ ฮ) Logic.โ ((ฯ โ ฮ) Logic.โจ (ฯ โ ฮ))
        [โถ]-maximal-membership =
          Logic.[โ]-symmetry [โข][โ]-equivalence โฆ Logic.[โ]-transitivity โฆโ
          [โ]-disjunctive-form                  โฆ Logic.[โ]-transitivity โฆโ
          [โข][โ]-equivalence                    โฆ Logic.[โ]-transitivity โฆโ
          [โจ]-maximal-membership                โฆ Logic.[โ]-transitivity โฆโ
          Logic.[โ]-intro
            (Either.mapLeft (Logic.[โ]-to-[โ] [ยฌ]-maximal-membership))
            (Either.mapLeft ((Logic.[โ]-to-[โ] [ยฌ]-maximal-membership)))

        [โท]-maximal-membership : ((ฯ โท ฯ) โ ฮ) Logic.โ (((ฯ โ ฮ) Logic.โง (ฯ โ ฮ)) Logic.โจ ((ฯ โ ฮ) Logic.โง (ฯ โ ฮ)))
        [โท]-maximal-membership =
          Logic.[โ]-symmetry [โข][โ]-equivalence โฆ Logic.[โ]-transitivity โฆโ
          [โท]-conjunction-disjunction-negation  โฆ Logic.[โ]-transitivity โฆโ
          [โข][โ]-equivalence                    โฆ Logic.[โ]-transitivity โฆโ
          [โจ]-maximal-membership                โฆ Logic.[โ]-transitivity โฆโ
          Logic.[โ]-intro
            (Either.map (Logic.[โ]-to-[โ] [โง]-maximal-membership) (Logic.[โ]-to-[โ] [โง]-maximal-membership))
            (Either.map (Logic.[โ]-to-[โ] [โง]-maximal-membership) (Logic.[โ]-to-[โ] [โง]-maximal-membership))
                                                โฆ Logic.[โ]-transitivity โฆโ
          Logic.[โ]-intro
            (Either.mapRight (Tuple.map (Logic.[โ]-to-[โ] [ยฌ]-maximal-membership) (Logic.[โ]-to-[โ] [ยฌ]-maximal-membership)))
            (Either.mapRight (Tuple.map (Logic.[โ]-to-[โ] [ยฌ]-maximal-membership) (Logic.[โ]-to-[โ] [ยฌ]-maximal-membership)))

        complete-membership : CompleteMembership
        complete-membership = Logic.[ยฌโ]-disjunctive-formแตฃ (Logic.[โ]-to-[โ] [ยฌ]-maximal-membership)

        equal-model-existence : Logic.โ(๐ โฆ (ฮ โกโ (๐ โง_)))
        equal-model-existence = Logic.[โ]-intro witness โฆ Logic.[โ]-intro l r โฆ where
          witness = (p โฆ Classical.decide{P = (โข p) โ ฮ} classical)

          l : (witness โง ฯ) โ (ฯ โ ฮ)
          r : witness โงโ ฮ

          r {โข x}   = Logic.[โ]-to-[โ] Logic.decide-is-true
          r {โค}     = Logic.[โ]-to-[โ] [โค]-maximal-membership
          r {โฅ}     = Logic.[โ]-to-[โ] [โฅ]-maximal-membership
          r {ยฌ ฯ}   = Logic.contrapositiveแตฃ l โ Logic.[โ]-to-[โ] [ยฌ]-maximal-membership
          r {ฯ โง ฯ} = Tuple.map r r โ Logic.[โ]-to-[โ] [โง]-maximal-membership
          r {ฯ โจ ฯ} = Either.map r r โ Logic.[โ]-to-[โ] [โจ]-maximal-membership
          r {ฯ โถ ฯ} = Either.map (Logic.contrapositiveแตฃ l) r โ Logic.[โ]-to-[โ] [โถ]-maximal-membership
          r {ฯ โท ฯ} = Either.map (Tuple.map r r) (Tuple.map (Logic.contrapositiveแตฃ l) (Logic.contrapositiveแตฃ l)) โ Logic.[โ]-to-[โ] [โท]-maximal-membership
      
          l {โข x}   = Logic.[โ]-to-[โ] Logic.decide-is-true
          l {โค}     = Logic.[โ]-to-[โ] [โค]-maximal-membership
          l {ยฌ ฯ}   = Logic.[โ]-to-[โ] [ยฌ]-maximal-membership โ Logic.contrapositiveแตฃ r
          l {ฯ โง ฯ} = Logic.[โ]-to-[โ] [โง]-maximal-membership โ Tuple.map l l
          l {ฯ โจ ฯ} = Logic.[โ]-to-[โ] [โจ]-maximal-membership โ Either.map l l
          l {ฯ โถ ฯ} = Logic.[โ]-to-[โ] [โถ]-maximal-membership โ Either.map (Logic.contrapositiveแตฃ r) l
          l {ฯ โท ฯ} = Logic.[โ]-to-[โ] [โท]-maximal-membership โ Either.map (Tuple.map l l) (Tuple.map (Logic.contrapositiveแตฃ r) (Logic.contrapositiveแตฃ r))

        satisfiable : Satisfiable(ฮ)
        satisfiable = Logic.[โ]-map-proof (\eq {ฯ} โ Logic.[โ]-to-[โ] (eq{ฯ})) equal-model-existence

    module ConsistentSubsetMaximality(p : ConsistentSubsetMaximality) where
      consistentElementMaximality : ConsistentElementMaximality
      consistentElementMaximality con = p con Left (Right [โก]-intro)

    module CompleteDerivability(p : CompleteDerivability) where
      module Consistent(consistent : Consistent(ฮ)) where
        [โข]-to-[โ]' : (ฮ โข ฯ) โ (ฯ โ ฮ)
        [โข]-to-[โ]' {ฯ = ฯ} = Logic.[โ]-disjunctive-formโ {!!}

        consistentSubsetMaximality : ConsistentSubsetMaximality
        consistentSubsetMaximality {ฮ} conฮ ฮฮ {ฯ} ฯฮ = {!Logic.[ยฌโ]-disjunctive-formโ (Either.map (weaken ฮฮ) (weaken ฮฮ) (p{ฯ}))!}
        {-with p{ฯ} | Logic.excluded-middle((ยฌ ฯ) โ ฮ)
        ... | Left  q | Left  r = {!!}
        ... | Left  q | Right r with () โ Logic.contrapositiveแตฃ(weaken ฮฮ) {!!} {!!}
        ... | Right q | _       with () โ conฮ([โฅ]-intro (direct ฯฮ) (weaken ฮฮ q))-}
        -- conฮ([โฅ]-intro (direct ฯฮ) (direct(ฮฮ ยฌฯฮ)))
        -- Logic.[โจ]-not-right (p{ฯ}) (ยฌฯฮ โฆ ?)

        consistentElementMaximality : ConsistentElementMaximality
        consistentElementMaximality {ฯ} conฮฯ with p{ฯ} | Logic.excluded-middle((ยฌ ฯ) โ ฮ)
        ... | Left  q | Left  r with () โ consistent([โฅ]-intro q (direct r))
        ... | Left  q | Right r = Logic.[ยฌยฌ]-elim (ยฌฮฯ โฆ {![ยฌ]-maximal-membershipแตฃ consistent !})
        ... | Right q | _       with () โ conฮฯ([ยฌ]-intro-converse q)
        -- ConsistentSubsetMaximality.consistentElementMaximality {!!}
        -- [โข]-deriviability-consistenceแตฃ consistent q
        -- [ยฌ]-intro(Logic.[โ]-to-[โ] [โข]-deriviability-inconsistence q)
        -- Logic.contrapositiveแตฃ direct conฮฯ
        -- (ยฌฯฮ โฆ Logic.contrapositiveแตฃ direct (conฮฯ โ [ยฌ]-intro-converse) {!r โ direct!})
        -- [ยฌ]-maximal-membershipแตฃ consistent
        -- (r โ direct)

        completeMembership : CompleteMembership
        completeMembership = Either.map [โข]-to-[โ] [โข]-to-[โ] p where
          [โข]-to-[โ] = (ConsistentElementMaximality.Consistent.[โข]-to-[โ] consistentElementMaximality consistent)

  record MaximallyConsistent (ฮ : Formulas(P){โ}) : Stmt{Lvl.๐(Lvl.of(P) Lvl.โ โ)} where
    field
      consistent : Consistent(ฮ)
      maximal    : ConsistentlyComplete(ฮ)

    subset-maximal  : ConsistentSubsetMaximality(ฮ)
    element-maximal : ConsistentElementMaximality(ฮ)

    element-maximal with maximal
    ... | subset-intro          p = ConsistentSubsetMaximality.consistentElementMaximality ฮ p
    ... | element-intro         p = p
    ... | complete-deriv-intro  p = ConsistentSubsetMaximality.consistentElementMaximality ฮ subset-maximal where
    ... | complete-member-intro p = ConsistentSubsetMaximality.consistentElementMaximality ฮ (CompleteMembership.consistentSubsetMaximality ฮ p)

    open ConsistentElementMaximality ฮ element-maximal using
      ( element-maximal-contra
      ; [โข]-deriviability-consistenceโ
      ) public

    open ConsistentElementMaximality.Consistent ฮ element-maximal consistent using
      ( [โข]-to-[โ]
      ; equal-model-existence
      ) public

    subset-maximal with maximal
    ... | subset-intro          p = p
    ... | element-intro         p = ConsistentElementMaximality.consistentSubsetMaximality ฮ p
    ... | complete-deriv-intro  p = CompleteMembership.consistentSubsetMaximality ฮ (Either.map [โข]-to-[โ] [โข]-to-[โ] p)
    ... | complete-member-intro p = CompleteMembership.consistentSubsetMaximality ฮ p

    {-r : (term-model(max ฮ con) โง ฯ) โ (ฯ โ max ฮ con)
    r {โข x}   modelsฯ ฮฯ-incons = Logic.[โ]-to-[โ] Logic.decide-is-true modelsฯ ฮฯ-incons
    r {โค}     modelsฯ ฮฯ-incons = con([โข]-compose-inconsistence [โค]-intro ฮฯ-incons)-}

  open MaximallyConsistent โฆ โฆ โฆ using
    ( [โข]-deriviability-consistenceโ
    ; [โค]-maximal-membership
    ; [โฅ]-maximal-membership
    ; [ยฌ]-maximal-membership
    ; [โง]-maximal-membership
    ; [โจ]-maximal-membership
    ; [โถ]-maximal-membership
    ; [โท]-maximal-membership
    ) public

  module _ โฆ countable-P : CountablyInfinite P โฆ where
    -- Also called: Lindenbaums' lemma
    open import Numeral.Natural
    private variable n : โ
    {-
    data maxi (ฮ : Formulas(P){โ}) : โ โ Formulas(P){Lvl.of(P) Lvl.โ โ} where
      base : ฮ        โ maxi ฮ ๐
      step : maxi ฮ n โ maxi ฮ (๐(n))
      form : let ฯ = Logic.[โ]-witness (Formula-is-countably-infinite {P = P}) n
             in  maxi ฮ (๐(n)) (if Logic.decide(maxi ฮ n โข ฯ) then ฯ else (ยฌ ฯ))

    maxi-zero : (ฮ โกโ maxi ฮ ๐)
    maxi-zero = Logic.[โ]-intro (\{(base p) โ p}) base

    maxi-succ : let ฯ = Logic.[โ]-witness (Formula-is-countably-infinite {P = P}) n in (((maxi ฮ n) โช singleton(if Logic.decide(maxi ฮ n โข ฯ) then ฯ else (ยฌ ฯ))) โกโ maxi ฮ (๐(n)))
    maxi-succ {n = n}{ฮ = ฮ} = Logic.[โ]-intro l r where
      p = Logic.[โ]-witness (Formula-is-countably-infinite {P = P}) n

      l : ((maxi ฮ n) โช singleton(if Logic.decide(maxi ฮ n โข p) then p else (ยฌ p))) โ maxi ฮ (๐(n))
      l (step x) = Left x
      l form     = Right [โก]-intro

      r : ((maxi ฮ n) โช singleton(if Logic.decide(maxi ฮ n โข p) then p else (ยฌ p))) โ maxi ฮ (๐(n))
      r (Left x)          = step x
      r (Right [โก]-intro) = form

    maxi-superset : Consistent(ฮ) โ (โ{n} โ (ฮ โ maxi ฮ n))
    maxi-superset {ฮ = ฮ} con {๐} = Logic.[โ]-to-[โ] maxi-zero
    maxi-superset {ฮ = ฮ} con {๐ n} {ฯ} ฮฯ = {!!}

    instance
      maxi-consistent : Consistent(ฮ) โ (โ{n} โ Consistent(maxi ฮ n))
      maxi-consistent         con {n = ๐}   = [โข]-subset-consistency (Logic.[โ]-to-[โ] maxi-zero) con
      maxi-consistent {ฮ = ฮ} con {n = ๐ n} = [โข]-subset-consistency (Logic.[โ]-to-[โ] maxi-succ) con-eq where
        p = Logic.[โ]-witness (Formula-is-countably-infinite {P = P}) n
        con-eq : Consistent((maxi ฮ n) โช singleton(if Logic.decide(maxi ฮ n โข p) then p else (ยฌ p)))
        con-eq with Logic.excluded-middle(maxi ฮ n โข p) | Logic.decide(maxi ฮ n โข p)
        ... | Left  derp  | _ = [โข]-compose-consistence derp (maxi-consistent con {n = n})
        ... | Right dernp | _ = [โฌ]-derives-negation-consistency(dernp โ [ยฌยฌ]-elim)
    -}

    maxi2 : Formulas(P){โ} โ โ โ Formulas(P){Lvl.of(P) Lvl.โ โ}
    maxi2 ฮ ๐      = Lvl.Up{Lvl.of(P)} โ ฮ
    maxi2 ฮ (๐(n)) = let ฯ = CountablyInfinite.index(Formula P) n
                     in  (maxi2 ฮ n) โช singleton(if Logic.decide(maxi2 ฮ n โข ฯ) then ฯ else (ยฌ ฯ))

    maxi2-succ : let ฯ = CountablyInfinite.index(Formula P) n in (((maxi2 ฮ n) โช singleton(if Logic.decide(maxi2 ฮ n โข ฯ) then ฯ else (ยฌ ฯ))) โกโ maxi2 ฮ (๐(n)))
    -- maxi2-succ {n = n}{ฮ = ฮ} = Logic.[โ]-intro {!!} {!!}

    maxi2-zero : (ฮ โกโ maxi2 ฮ ๐)
    maxi2-zero {ฮ = ฮ} = Logic.[โ]-symmetry (Sets.PredicateSet.LvlUp-set-equality {S = ฮ})

    maxi2-superset : โ{n} โ (ฮ โ maxi2 ฮ n)
    maxi2-superset {ฮ = ฮ} {๐}   = Logic.[โ]-to-[โ] (maxi2-zero {ฮ = ฮ})
    maxi2-superset {ฮ = ฮ} {๐ n} = Left โ maxi2-superset {ฮ = ฮ} {n}

    instance
      maxi2-consistent : Consistent(ฮ) โ (โ{n} โ Consistent(maxi2 ฮ n))
      maxi2-consistent {ฮ = ฮ} con {n = ๐}   = [โข]-subset-consistency (Logic.[โ]-to-[โ] (maxi2-zero {ฮ = ฮ})) con
      maxi2-consistent {ฮ = ฮ} con {n = ๐ n} = [โข]-subset-consistency (Logic.[โ]-to-[โ] (maxi2-succ {ฮ = ฮ})) con-eq where
        p = CountablyInfinite.index(Formula P) n
        con-eq : Consistent((maxi2 ฮ n) โช singleton(if Logic.decide(maxi2 ฮ n โข p) then p else (ยฌ p)))
        con-eq with Logic.excluded-middle(maxi2 ฮ n โข p) | Logic.decide(maxi2 ฮ n โข p)
        ... | Left  derp  | _ = [โข]-compose-consistence derp (maxi2-consistent con {n = n})
        ... | Right dernp | _ = [โฌ]-derives-negation-consistency(dernp โ [ยฌยฌ]-elim)

    max : (ฮ : Formulas(P){โ}) โ Formulas(P){Lvl.of(P) Lvl.โ โ}
    max(ฮ) ฯ = Logic.โ(n โฆ ฯ โ maxi2 ฮ n)

    maxi2-subset-max : (maxi2 ฮ n โ max ฮ)
    maxi2-subset-max {ฮ = ฮ} {n} p = Logic.[โ]-intro n โฆ p โฆ

    open import Lang.Inspect
    max-maximal : (ฯ โ max ฮ) Logic.โจ ((ยฌ ฯ) โ max ฮ)
    max-maximal {ฯ = ฯ}{ฮ = ฮ}
      with n โ CountablyInfinite.indexing(Formula P) ฯ
      with Logic.excluded-middle(maxi2 ฮ n โข CountablyInfinite.index(Formula P) n) | inspect(maxi2 ฮ) (๐ n)
    ... | Left  p | intro q with r โ [โก]-with(_$ CountablyInfinite.index(Formula P) n) q = Left  (Logic.[โ]-intro (๐(n)) โฆ Right {!!} โฆ)
    ... | Right p | intro q = Right (Logic.[โ]-intro (๐(n)) โฆ Right {!q!} โฆ)

    instance
      max-consistent : Consistent(ฮ) โ Consistent(max ฮ)
      max-consistent {ฮ = ฮ} con = [โข]-subset-consistency (Logic.[โ]-proof test5) (maxi2-consistent con {Logic.[โ]-witness test5}) where
        open import Numeral.Natural.Relation.Order
        open import Type.Properties.Inhabited

        test2 : (ฯ โ max ฮ) โ Logic.โ(n โฆ (ฯ โ maxi2 ฮ n))
        test2 p = p

        test3a : โ{ฯ} โ Logic.โ(n โฆ ((ฯ โ max ฮ) โ (ฯ โ maxi2 ฮ n)))
        test3a = Logic.[โ]-unrelatedแตฃ-[โ]โ โฆ pos = intro โฆ ๐ โฆ โฆ test2

        test3b : Logic.โ{Obj = Formula(P) โ โ}(n โฆ (max ฮ) โ (ฯ โฆ ฯ โ maxi2 ฮ (n(ฯ))))
        test3b = Logic.[โ][โ]-to-function-existence test3a

        test4 : โ{a b} โ (a โค b) โ โ{ฮ : Formulas(P){โ}} โ ((maxi2 ฮ a) โ (maxi2 ฮ b))
        test4 {a = ๐}   {๐}   [โค]-minimum                  p = p
        test4 {a = ๐}   {๐ b} [โค]-minimum           {ฮ}    p = Left(test4 {a = ๐}{b} [โค]-minimum {ฮ} p)
        test4 {a = ๐ a} {๐ b} ([โค]-with-[๐] โฆ ab โฆ) {ฮ}    (Left p)  = Left (test4 {a = a}{b} ab p)
        test4 {a = ๐ a} {๐ b} ([โค]-with-[๐] โฆ ab โฆ) {ฮ}{ฯ} (Right p) = {!test4 {a = a}{b = b} ab {ฮ โช singleton(if Logic.decide(maxi2 ฮ b โข ฮฒ) then ฮฒ else (ยฌ ฮฒ))}{ฯ} ? !} where
          ฮฒ = CountablyInfinite.index(Formula P) b
        {-with Logic.excluded-middle(maxi2 ฮ a โข Logic.[โ]-witness Formula-is-countably-infinite a) | p
        ... | Left x | [โก]-intro = {!!}
        ... | Right x | q = test4 {a} {๐ b} {!!} {!!}-}

        -- TODO: Because test3 and test4
        test5 : Logic.โ(n โฆ (max ฮ) โ (maxi2 ฮ n))

      -- with [โ]-intro n โฆ pn โฆ โ max ฮ = {!!}
      -- [โข]-subset-consistency (\{ฯ} โ {!maxi2-consistent con {n = ๐}!}) {!con!}

    instance
      max-maximally-consistent : Consistent(ฮ) โ MaximallyConsistent(max ฮ)
      MaximallyConsistent.consistent (max-maximally-consistent         con) = max-consistent con
      MaximallyConsistent.maximal    (max-maximally-consistent {ฮ = ฮ} con) = {!!}
      -- {ฯ} conm with n โ CountablyInfinite.indexing(Formula P) ฯ = {!!}

    max-superset : ฮ โ max ฮ
    max-superset {ฮ = ฮ} ฮฯ = Logic.[โ]-intro ๐ โฆ maxi2-superset {ฮ = ฮ}{n = ๐} ฮฯ โฆ

{-

  {-
  max : (ฮ : Formulas(P){โ}) โ Consistent(ฮ) โ Formulas(P){Lvl.๐(Lvl.of(P) Lvl.โ โ)}
  max ฮ con ฯ = Consistent(ฮ โช singleton(ฯ)) -- TODO: Probably not like this. The problem with this definition is that (Consistent(ฮ โช singleton(ฯ)) โ (ฮ โข ฯ)) is impossible to prove, and it is neccessary for proving that (max ฮ con) for any ฮ is a consistent set of formulas. This is related to the issue that if both (ฮ โช singleton(ฯ)) and (ฮ โช singleton(ยฌ ฯ)) is consistent, then both of them will be included. But this would lead to (max ฮ cons) not necccesarily consistent.
  -- if decide(Consistent(ฮ โช singleton(ฯ))) then (ฮ โช singleton(ฯ)) else (ฮ โช singleton(ยฌ ฯ))
  {-data max2 (ฮ : Formulas(P){โ}) (con : Consistent(ฮ)) : Formulas(P){Lvl.๐(Lvl.of(P) Lvl.โ โ)} where
    Positive : Consistent  (ฮ โช singleton(ฯ)) โ Inconsistent(ฮ โช singleton(ยฌ ฯ)) โ max2 ฮ con ฯ
    Negative : Inconsistent(ฮ โช singleton(ฯ)) โ Consistent  (ฮ โช singleton(ยฌ ฯ)) โ max2 ฮ con ฯ
  -}
  max2 : (ฮ : Formulas(P){โ}) โ Consistent(ฮ) โ Formulas(P){Lvl.๐(Lvl.of(P) Lvl.โ โ)}
  max2 ฮ con ฯ = Consistent(ฮ โช singleton(ฯ)) Logic.โง Inconsistent(ฮ โช singleton(ยฌ ฯ))

  max-maximal : โ{con : Consistent(ฮ)} โ (ฯ โ max ฮ con) Logic.โจ ((ยฌ ฯ) โ max ฮ con)
  max-maximal {ฮ = ฮ}{ฯ = ฯ}{con = con} with Logic.excluded-middle(Inconsistent(ฮ โช singleton(ฯ))) โฆ classical โฆ
  ... | Logic.[โจ]-introโ  ฮฯโฅ = Logic.[โจ]-introแตฃ (ฮยฌฯโฅ โฆ Logic.[โฅ]-elim(con ([โฅ]-intro ([ยฌ]-elim ฮยฌฯโฅ) ([ยฌ]-intro ฮฯโฅ))))
  ... | Logic.[โจ]-introแตฃ ยฌฮฯโฅ = Logic.[โจ]-introโ ยฌฮฯโฅ

  max-no-bottom : โ{con : Consistent(ฮ)} โ (โฅ โ max ฮ con)
  max-no-bottom = apply(direct(Right [โก]-intro))

  max-consistent-containment : โ{con : Consistent(ฮ)} โ (ฯ โ max ฮ con) โ ((ยฌ ฯ) โ max ฮ con) โ Logic.โฅ
  max-consistent-containment {ฮ = ฮ}{ฯ = ฯ}{con = con} ยฌฮฯโฅ ยฌฮยฌฯโฅ = ยฌฮฯโฅ ([โฅ]-intro (direct (Right [โก]-intro)) {!!})

  max-consistency-membership : โ{con} โ Consistent(ฮ โช singleton(ฯ)) Logic.โ (ฯ โ max ฮ con)
  max-consistency-membership = Logic.[โ]-intro id id

  max-inconsistency-membership2 : โ{con} โ Inconsistent(ฮ โช singleton(ฯ)) Logic.โ (ฯ โ max ฮ con)
  max-inconsistency-membership2 = Logic.[โ]-intro Logic.[ยฌยฌ]-elim apply

  test : โ{con} โ (ฯ โ max ฮ con) โ ((ยฌ ฯ) โ max ฮ con)
  test {con = con} p = [โข]-compose-consistence ([ยฌ]-intro(Logic.[ยฌยฌ]-elim p)) con

  max-consistent : โ{con : Consistent(ฮ)} โ Consistent(max ฮ con)
  max-consistent {ฮ = ฮ} {con = con} = Logic.contrapositiveแตฃ {!!} con
  {-max-consistent {ฮ = ฮ} {con = con} (direct x)        = max-no-bottom{con = con} x
  max-consistent {ฮ = ฮ} {con = con} ([โฅ]-intro p q)   = {!max-consistent q!}
  max-consistent {ฮ = ฮ} {con = con} ([โฅ]-elim  p)     = max-consistent{con = con} p
  max-consistent {ฮ = ฮ} {con = con} ([ยฌ]-elim  p)     = {!!}
  max-consistent {ฮ = ฮ} {con = con} ([โง]-elimโ p)     = {!max-consistent !}
  max-consistent {ฮ = ฮ} {con = con} ([โง]-elimแตฃ p)     = {!!}
  max-consistent {ฮ = ฮ} {con = con} ([โจ]-elim  p q r) = {!!}
  max-consistent {ฮ = ฮ} {con = con} ([โถ]-elim  p q)   = {!!}
  max-consistent {ฮ = ฮ} {con = con} ([โท]-elimโ p q)   = {!!}
  max-consistent {ฮ = ฮ} {con = con} ([โท]-elimแตฃ p q)   = {!!}-}

  {-
  test2 : โ{con} โ ((ยฌ ฯ) โ max ฮ con) โ (ฯ โ max ฮ con)
  test2 {con = con} p q = {!!}

  test3 : โ{con} โ (max ฮ con โข ฯ) โ (ฮ โข ฯ)
  test3 {ฮ = ฮ} {ฯ} {con = con} (direct x) = {!!}
  test3 {ฮ = ฮ} {.โค} {con = con} [โค]-intro = {!!}
  test3 {ฮ = ฮ} {.โฅ} {con = con} ([โฅ]-intro p pโ) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โฅ]-elim p) = {!!}
  test3 {ฮ = ฮ} {.(ยฌ _)} {con = con} ([ยฌ]-intro p) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([ยฌ]-elim p) = {!!}
  test3 {ฮ = ฮ} {.(_ โง _)} {con = con} ([โง]-intro p pโ) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โง]-elimโ p) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โง]-elimแตฃ p) = {!!}
  test3 {ฮ = ฮ} {.(_ โจ _)} {con = con} ([โจ]-introโ p) = {!!}
  test3 {ฮ = ฮ} {.(_ โจ _)} {con = con} ([โจ]-introแตฃ p) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โจ]-elim p pโ pโ) = {!!}
  test3 {ฮ = ฮ} {.(_ โถ _)} {con = con} ([โถ]-intro p) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โถ]-elim p pโ) = {!!}
  test3 {ฮ = ฮ} {.(_ โท _)} {con = con} ([โท]-intro p pโ) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โท]-elimโ p pโ) = {!!}
  test3 {ฮ = ฮ} {ฯ} {con = con} ([โท]-elimแตฃ p pโ) = {!!}
  -}

  max-inconsistency-membership : โ{con} โ Inconsistent(ฮ โช singleton(ฯ)) Logic.โ ((ยฌ ฯ) โ max ฮ con)
  max-inconsistency-membership {ฮ = ฮ}{ฯ = ฯ}{con = con} =
    Logic.double-negation โฆ Logic.[โ]-transitivity โฆโ
    Logic.[ยฌ]-unaryOperator max-consistency-membership โฆ Logic.[โ]-transitivity โฆโ
    Logic.[โ]-intro
      ll
      (ฮยฌฯ-incons โฆ ฮฯ-incons โฆ con([โฅ]-intro ([ยฌ]-elim ฮฯ-incons) ([ยฌ]-intro (Logic.[ยฌยฌ]-elim ฮยฌฯ-incons))))
    where
      ll : Logic.ยฌ((ฮ โช singleton(ยฌ ฯ)) โข โฅ) โ Logic.ยฌ((ฮ โช singleton(ฯ)) โข โฅ) โ Empty
      ll ยฌฯin ฯin = {!!}
      -- () โ ยฌฯin([โฅ]-intro {!!} (direct (Right [โก]-intro)))
      -- con([โฅ]-intro {!!} {!!})
      -- 
      -- {![โฅ]-intro (direct ฯin) (direct ยฌฯin)!})
  -- Logic.contrapositiveโ โฆ classical โฆ (ฮยฌฯ-incons โฆ ฮฯ-incons โฆ con([โฅ]-intro ([ยฌ]-elim (Logic.[ยฌยฌ]-elim ฮยฌฯ-incons)) ([ยฌ]-intro ฮฯ-incons)))

  max-superset : โ{con : Consistent(ฮ)} โ (ฮ โ max ฮ con)
  max-superset {con = con} {x = ฯ} ฯฮ ฮฯโฅ = con ([โฅ]-intro (direct ฯฮ) ([ยฌ]-intro ฮฯโฅ))

  -- TODO: Are there any easy ways to prove this?
  instance
    max-maximally-consistent : โ{con : Consistent(ฮ)} โ MaximallyConsistent(max ฮ con)
    MaximallyConsistent.consistent (max-maximally-consistent {con = con}) = max-consistent{con = con}
    MaximallyConsistent.element-maximal max-maximally-consistent p = {!!} -- max-consistency-membership {!Logic.contrapositive-variant2โ weaken-union-singleton!} -- max-consistency-membership {!p!}

  -- max-[โข]-subset : โ{con : Consistent(ฮ)} โ ((max ฮ con โข_) โ (ฮ โข_))
  -- max-[โข]-subset {con = con} p = {!!}
-}
-}

module _ where
  open NaturalDeduction

  private variable P : Type{โโ}
  private variable ฯ ฯ : Formula(P)

  module _ where
    private variable ฮ ฮโ ฮโ : Formulas(P){โโ}

    soundness : (ฮ โข ฯ) โ (ฮ โจ ฯ)
    soundness (direct ฮฯ) ๐ฮ            = ๐ฮ(ฮฯ)
    soundness [โค]-intro                 = const(Logic.[โค]-intro)
    soundness ([โฅ]-intro ฮฯ ฮยฌฯ) ๐ฮ     = (soundness ฮยฌฯ ๐ฮ) (soundness ฮฯ ๐ฮ)
    soundness ([โฅ]-elim ฮโฅ) ๐ฮ          = Logic.[โฅ]-elim(soundness ฮโฅ ๐ฮ)
    soundness {ฮ = ฮ}{ฯ = ฯ} ([ยฌ]-intro ฮฯโฅ) ๐ฮ ๐ฯ = soundness ฮฯโฅ ([โงโ]-strengthen {ฮโ = ฮ}{ฮโ = singleton _} (๐ฮ) (Logic.[โ]-to-[โ] [โง]-to-[โงโ] ๐ฯ))
    soundness {ฮ = ฮ}{ฯ = ฯ} ([ยฌ]-elim ฮยฌฯโฅ) {๐} ๐ฮ = Logic.[ยฌยฌ]-elim {P = (๐ โง ฯ)} (ยฌ๐ฯ โฆ soundness ฮยฌฯโฅ ([โงโ]-strengthen {ฮโ = ฮ}{ฮโ = singleton _} ๐ฮ (Logic.[โ]-to-[โ] [โง]-to-[โงโ] ยฌ๐ฯ)))
    soundness ([โง]-intro ฮฯ ฮฯ) ๐ฮ = (Logic.[โง]-intro (soundness ฮฯ ๐ฮ) (soundness ฮฯ ๐ฮ))
    soundness ([โง]-elimโ ฮฯฯ) = Logic.[โง]-elimโ โ (soundness ฮฯฯ)
    soundness ([โง]-elimแตฃ ฮฯฯ) = Logic.[โง]-elimแตฃ โ (soundness ฮฯฯ)
    soundness ([โจ]-introโ ฮฯ) = Logic.[โจ]-introโ โ (soundness ฮฯ)
    soundness ([โจ]-introแตฃ ฮฯ) = Logic.[โจ]-introแตฃ โ (soundness ฮฯ)
    soundness {ฮ = ฮ}{ฯ = ฯ} ([โจ]-elim {ฯ = ฯโ} {ฯโ} ฮฯโฯ ฮฯโฯ ฮฯโฯโ) {๐} ๐ฮ =
      (Logic.[โจ]-elim
        (๐ฯโ โฆ soundness ฮฯโฯ ([โงโ]-strengthen {ฮโ = ฮ}{ฮโ = singleton _} (๐ฮ) (Logic.[โ]-to-[โ] [โง]-to-[โงโ] ๐ฯโ)))
        (๐ฯโ โฆ soundness ฮฯโฯ ([โงโ]-strengthen {ฮโ = ฮ}{ฮโ = singleton _} (๐ฮ) (Logic.[โ]-to-[โ] [โง]-to-[โงโ] ๐ฯโ)))
        (soundness ฮฯโฯโ ๐ฮ)
      )
    soundness {ฮ = ฮ} ([โถ]-intro ฮฯฯ) ๐ฮ = Logic.[โ]-disjunctive-formแตฃ (๐ฯ โฆ soundness ฮฯฯ ([โงโ]-strengthen {ฮโ = ฮ}{ฮโ = singleton _} (๐ฮ) (Logic.[โ]-to-[โ] [โง]-to-[โงโ] ๐ฯ)))
    soundness ([โถ]-elim ฮฯ ฮฯฯ) ๐ฮ = Logic.[โ]-disjunctive-formโ((soundness ฮฯฯ) ๐ฮ) (soundness ฮฯ ๐ฮ)
    soundness {ฮ = ฮ} ([โท]-intro {ฯ = ฯ} {ฯ = ฯ} ฮฯฯ ฮฯฯ) {๐} ๐ฮ with Logic.excluded-middle(๐ โง ฯ) | Logic.excluded-middle(๐ โง ฯ)
    ... | Logic.[โจ]-introโ ๐ฯ  | Logic.[โจ]-introโ ๐ฯ  = Logic.[โจ]-introโ (Logic.[โง]-intro ๐ฯ ๐ฯ)
    ... | Logic.[โจ]-introโ ๐ฯ  | Logic.[โจ]-introแตฃ ยฌ๐ฯ = (Logic.[โฅ]-elim โ ยฌ๐ฯ โ soundness ฮฯฯ) (Logic.[โจ]-elim ๐ฮ \{[โก]-intro โ ๐ฯ})
    ... | Logic.[โจ]-introแตฃ ยฌ๐ฯ | Logic.[โจ]-introโ ๐ฯ  = (Logic.[โฅ]-elim โ ยฌ๐ฯ โ soundness ฮฯฯ) (Logic.[โจ]-elim ๐ฮ \{[โก]-intro โ ๐ฯ})
    ... | Logic.[โจ]-introแตฃ ยฌ๐ฯ | Logic.[โจ]-introแตฃ ยฌ๐ฯ = Logic.[โจ]-introแตฃ (Logic.[โง]-intro ยฌ๐ฯ ยฌ๐ฯ)
    soundness {ฮ = ฮ} ([โท]-elimโ {ฯ = ฯ} {ฯ = ฯ} ฮฯ ฮฯฯ) ๐ฮ with soundness ฮฯฯ ๐ฮ
    ... | Logic.[โจ]-introโ(Logic.[โง]-intro ๐ฯ  ๐ฯ ) = ๐ฯ
    ... | Logic.[โจ]-introแตฃ(Logic.[โง]-intro ยฌ๐ฯ ยฌ๐ฯ) = Logic.[โฅ]-elim(ยฌ๐ฯ(soundness ฮฯ ๐ฮ))
    soundness {ฮ = ฮ} ([โท]-elimแตฃ {ฯ = ฯ} {ฯ = ฯ} ฮฯ ฮฯฯ) ๐ฮ with soundness ฮฯฯ ๐ฮ
    ... | Logic.[โจ]-introโ(Logic.[โง]-intro ๐ฯ  ๐ฯ ) = ๐ฯ
    ... | Logic.[โจ]-introแตฃ(Logic.[โง]-intro ยฌ๐ฯ ยฌ๐ฯ) = Logic.[โฅ]-elim(ยฌ๐ฯ(soundness ฮฯ ๐ฮ))

    satisfiable-consistent : Satisfiable(ฮ) โ Consistent(ฮ)
    satisfiable-consistent sat = Logic.contrapositiveแตฃ soundness (\p โ Logic.[โ]-to-[โ] [โจ]-unsatisfiability p sat)

    consistency-of-โ : Consistent{P = P}{โ = โ}(โ)
    consistency-of-โ = satisfiable-consistent [โ]-satisfiable

  module _ where
    open import Data.Boolean.Stmt.Proofs
    open import Lang.Inspect

    modelSet : Model(P) โ Formulas(P)
    modelSet(๐) = ๐ โง_

    module _ {๐ : Model(P)} where
      modelSet-satisfiable : Satisfiable(modelSet(๐))
      modelSet-satisfiable = Logic.[โ]-intro ๐ โฆ id โฆ

      modelSet-maximally-consistent : MaximallyConsistent(modelSet(๐))
      MaximallyConsistent.consistent modelSet-maximally-consistent = satisfiable-consistent modelSet-satisfiable
      MaximallyConsistent.maximal    modelSet-maximally-consistent = element-intro p where
        p : ConsistentElementMaximality(modelSet(๐))
        p {ฯ} cons with TruthTable.eval ๐ ฯ | inspect (TruthTable.eval ๐) ฯ
        ... | ๐ | intro eval-๐ = TruthTable.eval-to-models {ฯ = ฯ} (Logic.[โ]-to-[โ] IsTrue.is-๐ eval-๐)
        ... | ๐น | intro eval-๐น = Logic.[โฅ]-elim (cons ([โฅ]-intro (direct (Right [โก]-intro)) (weaken Left (direct (TruthTable.eval-to-models {ฯ = ยฌ ฯ} (Logic.[โ]-to-[โ] IsTrue.is-๐ ([โก]-with(BoolOp.ยฌ) eval-๐น)))))))

      {-maximally-consistent-is-modelSet : MaximallyConsistent(ฮ) โ (ฮ โกโ modelSet(๐))
      maximally-consistent-is-modelSet maxCon {โข x} = Logic.[โ]-intro {!Logic.[โ]-to-[โ] Logic.decide-is-true!} {!Logic.[โ]-to-[โ] Logic.decide-is-true!}
      maximally-consistent-is-modelSet maxCon {โค} = [โค]-maximal-membership โฆ maxCon โฆ
      maximally-consistent-is-modelSet maxCon {โฅ} = [โฅ]-maximal-membership โฆ maxCon โฆ
      maximally-consistent-is-modelSet maxCon {ยฌ ฯ} = Logic.[โ]-transitivity ([ยฌ]-maximal-membership โฆ maxCon โฆ) (Logic.[ยฌ]-unaryOperator (maximally-consistent-is-modelSet maxCon))
      maximally-consistent-is-modelSet maxCon {ฯ โง ฯ} = Logic.[โ]-transitivity ([โง]-maximal-membership โฆ maxCon โฆ) (Logic.[โง]-binaryOperator (maximally-consistent-is-modelSet maxCon) (maximally-consistent-is-modelSet maxCon))
      maximally-consistent-is-modelSet maxCon {ฯ โจ ฯ} = Logic.[โ]-transitivity ([โจ]-maximal-membership โฆ maxCon โฆ) (Logic.[โจ]-binaryOperator (maximally-consistent-is-modelSet maxCon) (maximally-consistent-is-modelSet maxCon))
      maximally-consistent-is-modelSet maxCon {ฯ โถ ฯ} = {!!}
      maximally-consistent-is-modelSet maxCon {ฯ โท ฯ} = {!!}-}

    term-model : Formulas(P){โ} โ Model(P)
    term-model(ฮ) p = Classical.decide {P = (โข p) โ ฮ} classical

  module _ โฆ countable-P : CountablyInfinite(P) โฆ where
    private variable ฮ ฮโ ฮโ : Formulas(P){โโ}

    term-model-of-max-proof : (con : Consistent(ฮ)) โ (max ฮ โกโ (term-model(max ฮ) โง_))
    term-model-of-max-proof {ฮ = ฮ} con = Logic.[โ]-proof(MaximallyConsistent.equal-model-existence (max-maximally-consistent con))

    consistent-satisfiable : Consistent(ฮ) โ Satisfiable(ฮ)
    Logic.โ.witness (consistent-satisfiable {ฮ = ฮ} con)     = term-model(max ฮ)
    Logic.โ.proof   (consistent-satisfiable {ฮ = ฮ} con) {ฮณ} = (Logic.[โ]-to-[โ] (term-model-of-max-proof {ฮ = ฮ} con {ฮณ})) โ max-superset

    completeness : (ฮ โจ ฯ) โ (ฮ โข ฯ)
    completeness {ฮ = ฮ}{ฯ = ฯ} =
      (Logic.[โ]-to-[โ] [โข]-deriviability-inconsistence)
      โ (Logic.[โ]-to-[โ] Logic.contrapositive-variant2 consistent-satisfiable)
      โ (Logic.[โ]-to-[โ] [โจ]-entailment-unsatisfiability)
